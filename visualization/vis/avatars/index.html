<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spark â€¢ Animated Viewer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    #loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-family: Arial, sans-serif; 
    }

  </style>
</head>

<body>
  <!-- Loading Screen -->
  <div id="loading-screen">
    <img src="loading.gif" />
    <p>Loading files, please wait...</p>
  </div>

  <script type="importmap">
    {
      "imports": {
        "@sparkjsdev/spark": "/dist/spark.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { GUI } from "lil-gui";
    import { SplatMesh } from "@sparkjsdev/spark";
    import { FontLoader } from "three/examples/jsm/loaders/FontLoader.js";
    import { TextGeometry } from "three/examples/jsm/geometries/TextGeometry.js";

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // Set background to black

    // Create a simple plane floor
    const floorGeometry = new THREE.PlaneGeometry(5, 5); // Width and height of the plane
    const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 }); // Gray color
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);

    // Rotate the plane to lie flat on the XZ plane
    floor.rotation.x = -Math.PI / 2;

    // Position the floor slightly below the origin
    floor.position.y = -.65;

    // Add the floor to the scene
    scene.add(floor);

    // Add the logo "AViMO" on the floor
    const fontLoader = new FontLoader();
    fontLoader.load('./assets/fonts/optimer_regular.typeface.json', (font) => {
      const textGeometry = new TextGeometry('AViMO', {
        font: font,
        size: 0.25, // Size of the text
        depth: 0.1, // Depth of the text
        bevelEnabled: false, // Disable bevel for cleaner text
      });

      const textMaterial = new THREE.MeshBasicMaterial({ color: 0x12a4a4  });
      const textMesh = new THREE.Mesh(textGeometry, textMaterial);

      // Position the text vertically on the floor
      textMesh.rotation.x = 0; // No rotation along the X-axis (vertical orientation)
      textMesh.position.set(-2.3, -.65, -2.4); // Adjust position to sit vertically on the floor

      scene.add(textMesh);
    });
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(-2, 2, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const orbitControls = new OrbitControls(camera, renderer.domElement);
    orbitControls.enabled = false;
    orbitControls.target.set(0, 0, 0);
    orbitControls.update();

    const options = {
      autoRotate: false,
      orbit: true,
      playAnimation: false,
      fps: 60
    };

    const gui = new GUI({ title: "Controls" });
    gui.add(options, "autoRotate").name("Auto Rotate");
    gui.add(options, "orbit").name("Orbit Controls").onChange(enabled => {
      orbitControls.enabled = enabled;
      orbitControls.update();
    });
    gui.add(options, "playAnimation").name("Play Animation");
    gui.add(options, "fps", 1, 60, 1).name("FPS");

    // Add "Flip Coordinate System" option to the GUI
    options.flipCoordinateSystem = false;
    gui.add(options, "flipCoordinateSystem").name("Flip Coordinate System").onChange((isFlipped) => {
      splatFrames.forEach((frame) => {
        if (isFlipped) {
          frame.rotation.y = Math.PI; // Rotate 180 degrees around the Y-axis
          frame.rotation.x = Math.PI; // Rotate 180 degrees around the X-axis to correct upside-down orientation
        } else {
          frame.rotation.y = 0; // Reset rotation
          frame.rotation.x = 0; // Reset rotation
        }
      });
    });
    // Add the video recording functionality here
    let mediaRecorder;
    let recordedChunks = [];

    // Add "Record Video" option to the GUI
    options.recordVideo = false;
    gui.add(options, "recordVideo").name("Record Video").onChange((isRecording) => {
      if (isRecording) {
        startRecording();
      } else {
        stopRecording();
      }
    });


    function startRecording() {
      const canvas = renderer.domElement;
      const stream = canvas.captureStream(30); // Capture at 30 FPS
      mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm" });

      recordedChunks = [];
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          recordedChunks.push(event.data);
        }
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);

        // Create a download link for the video
        const a = document.createElement("a");
        a.href = url;
        a.download = "interaction_recording.webm";
        a.style.display = "none";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      };

      mediaRecorder.start();
      console.log("Recording started...");
    }

    function stopRecording() {
      if (mediaRecorder) {
        mediaRecorder.stop();
        console.log("Recording stopped...");
      }
    }
    const splatFrames = [];
    let currentFrame = 0;
    let lastFrameTime = 0;
    const totalFrames = 100; // Change to match your file count

    async function loadSplatFrame(index) {
      // const path = `./splats_8_2/splat_${index.toString().padStart("0")}.spz`;
      const path = 'your avatars path'

      const mesh = new SplatMesh({ url: path });
      await mesh.initialized;

      mesh.quaternion.set(1, 0, 0, 0);
      mesh.visible = false;
      return mesh;
    }

    async function loadAllSplatFrames() {
      for (let i = 0; i < totalFrames; i++) {
        const mesh = await loadSplatFrame(i);
        splatFrames.push(mesh);
      }

      scene.add(splatFrames[0]);
      splatFrames[0].visible = true;

      // Hide the loading screen once all frames are loaded
      document.getElementById("loading-screen").style.display = "none";
    }

    loadAllSplatFrames();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function switchToFrame(index) {
      if (splatFrames[currentFrame]) {
        scene.remove(splatFrames[currentFrame]);
      }
      currentFrame = index % splatFrames.length;
      const next = splatFrames[currentFrame];
      scene.add(next);
      next.visible = true;
    }

    renderer.setAnimationLoop((time) => {
      if (options.playAnimation && time - lastFrameTime > 1000 / options.fps) {
        const nextFrame = (currentFrame + 1) % splatFrames.length;
        switchToFrame(nextFrame);
        lastFrameTime = time;
      }

      if (options.autoRotate && splatFrames[currentFrame]) {
        splatFrames[currentFrame].rotation.y += 0.01;
      }

      orbitControls.update();
      renderer.render(scene, camera);
    });
  </script>
</body>

</html>
