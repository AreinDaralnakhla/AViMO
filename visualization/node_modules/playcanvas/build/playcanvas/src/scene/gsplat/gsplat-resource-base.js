import { BoundingBox } from '../../core/shape/bounding-box.js';
import { TYPE_UINT32, SEMANTIC_ATTR13, BUFFER_STATIC, ADDRESS_CLAMP_TO_EDGE, FILTER_NEAREST } from '../../platform/graphics/constants.js';
import { Texture } from '../../platform/graphics/texture.js';
import { VertexFormat } from '../../platform/graphics/vertex-format.js';
import { VertexBuffer } from '../../platform/graphics/vertex-buffer.js';
import { Mesh } from '../mesh.js';

class GSplatResourceBase {
		constructor(device, gsplatData){
				this.device = device;
				this.gsplatData = gsplatData;
				this.centers = new Float32Array(gsplatData.numSplats * 3);
				gsplatData.getCenters(this.centers);
				this.aabb = new BoundingBox();
				gsplatData.calcAabb(this.aabb);
				const splatInstanceSize = 128;
				const numSplats = Math.ceil(gsplatData.numSplats / splatInstanceSize) * splatInstanceSize;
				const numSplatInstances = numSplats / splatInstanceSize;
				const indexData = new Uint32Array(numSplatInstances);
				for(let i = 0; i < numSplatInstances; ++i){
						indexData[i] = i * splatInstanceSize;
				}
				const vertexFormat = new VertexFormat(device, [
						{
								semantic: SEMANTIC_ATTR13,
								components: 1,
								type: TYPE_UINT32,
								asInt: true
						}
				]);
				const meshPositions = new Float32Array(12 * splatInstanceSize);
				const meshIndices = new Uint32Array(6 * splatInstanceSize);
				for(let i = 0; i < splatInstanceSize; ++i){
						meshPositions.set([
								-1,
								-1,
								i,
								1,
								-1,
								i,
								1,
								1,
								i,
								-1,
								1,
								i
						], i * 12);
						const b = i * 4;
						meshIndices.set([
								0 + b,
								1 + b,
								2 + b,
								0 + b,
								2 + b,
								3 + b
						], i * 6);
				}
				this.mesh = new Mesh(device);
				this.mesh.setPositions(meshPositions, 3);
				this.mesh.setIndices(meshIndices);
				this.mesh.update();
				this.mesh.incRefCount();
				this.mesh.aabb.copy(this.aabb);
				this.instanceIndices = new VertexBuffer(device, vertexFormat, numSplatInstances, {
						usage: BUFFER_STATIC,
						data: indexData.buffer
				});
		}
		destroy() {
				this.mesh?.destroy();
				this.instanceIndices?.destroy();
		}
		get instanceSize() {
				return 128;
		}
		get numSplats() {
				return this.gsplatData.numSplats;
		}
		configureMaterial(material) {}
		evalTextureSize(count) {}
		createTexture(name, format, size, data) {
				return new Texture(this.device, {
						name: name,
						width: size.x,
						height: size.y,
						format: format,
						cubemap: false,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE,
						...data ? {
								levels: [
										data
								]
						} : {}
				});
		}
		instantiate() {}
}

export { GSplatResourceBase };
