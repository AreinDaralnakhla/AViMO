declare const _default: "\n#include \"screenDepthPS\"\n\nvarying uv0: vec2f;\n\nvar sourceTexture: texture_2d<f32>;\nvar sourceTextureSampler: sampler;\nuniform sourceInvResolution: vec2f;\nuniform filterSize: i32;\n\nfn random(w: vec2f) -> f32 {\n    const m: vec3f = vec3f(0.06711056, 0.00583715, 52.9829189);\n    return fract(m.z * fract(dot(w, m.xy)));\n}\n\nfn bilateralWeight(depth: f32, sampleDepth: f32) -> f32 {\n    let diff: f32 = (sampleDepth - depth);\n    return max(0.0, 1.0 - diff * diff);\n}\n\nfn tap(sum_ptr: ptr<function, f32>, totalWeight_ptr: ptr<function, f32>, weight: f32, depth: f32, position: vec2f) {\n\n    let color: f32 = textureSample(sourceTexture, sourceTextureSampler, position).r;\n    let textureDepth: f32 = -getLinearScreenDepth(position);\n\n    let bilateral: f32 = bilateralWeight(depth, textureDepth) * weight;\n\n    *sum_ptr = *sum_ptr + color * bilateral;\n    *totalWeight_ptr = *totalWeight_ptr + bilateral;\n}\n\n// TODO: weights of 1 are used for all samples. Test with gaussian weights\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n    var output: FragmentOutput;\n\n    // handle the center pixel separately because it doesn't participate in bilateral filtering\n    let depth: f32 = -getLinearScreenDepth(input.uv0);\n    var totalWeight: f32 = 1.0;\n    let color: f32 = textureSample(sourceTexture, sourceTextureSampler, input.uv0 ).r;\n    var sum: f32 = color * totalWeight;\n\n    for (var i: i32 = -uniform.filterSize; i <= uniform.filterSize; i = i + 1) {\n        let weight: f32 = 1.0;\n\n        #ifdef HORIZONTAL\n            var offset: vec2f = vec2f(f32(i), 0.0) * uniform.sourceInvResolution;\n        #else\n            var offset: vec2f = vec2f(0.0, f32(i)) * uniform.sourceInvResolution;\n        #endif\n\n        tap(&sum, &totalWeight, weight, depth, input.uv0 + offset);\n    }\n\n    let ao: f32 = sum / totalWeight;\n\n    // simple dithering helps a lot (assumes 8 bits target)\n    // this is most useful with high quality/large blurs\n    // ao += ((random(gl_FragCoord.xy) - 0.5) / 255.0);\n\n    output.color = vec4f(ao, ao, ao, 1.0);\n    return output;\n}\n";
export default _default;
