declare const _default: "\n//RG=X, BA=Y\n//RG=Z, BA=A\n//RGB=V, A=visMode\n//RGBA=life\n\nconst PI2: f32 = 6.283185307179586;\n\nuniform inBoundsSize: vec3f;\nuniform inBoundsCenter: vec3f;\n\nuniform maxVel: f32;\n\nfn decodeFloatRG(rg: vec2f) -> f32 {\n    return rg.y * (1.0 / 255.0) + rg.x;\n}\n\nfn decodeFloatRGBA( rgba: vec4f ) -> f32 {\n    return dot(rgba, vec4f(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\n\nfn readInput(uv: f32) {\n    let tex0 = textureSampleLevel(particleTexIN, particleTexINSampler, vec2f(uv, 0.125), 0.0);\n    let tex1 = textureSampleLevel(particleTexIN, particleTexINSampler, vec2f(uv, 0.375), 0.0);\n    let tex2 = textureSampleLevel(particleTexIN, particleTexINSampler, vec2f(uv, 0.625), 0.0);\n    let tex3 = textureSampleLevel(particleTexIN, particleTexINSampler, vec2f(uv, 0.875), 0.0);\n\n    inPos = vec3f(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n    inPos = (inPos - vec3f(0.5)) * uniform.inBoundsSize + uniform.inBoundsCenter;\n\n    inVel = tex2.xyz;\n    inVel = (inVel - vec3f(0.5)) * uniform.maxVel;\n\n    inAngle = decodeFloatRG(tex1.ba) * PI2;\n    inShow = tex2.a > 0.5;\n\n    let life_decoded = decodeFloatRGBA(tex3);\n    let maxNegLife = max(uniform.lifetime, (uniform.numParticles - 1.0) * (uniform.rate + uniform.rateDiv));\n    let maxPosLife = uniform.lifetime + 1.0;\n    inLife = life_decoded * (maxNegLife + maxPosLife) - maxNegLife;\n}";
export default _default;
