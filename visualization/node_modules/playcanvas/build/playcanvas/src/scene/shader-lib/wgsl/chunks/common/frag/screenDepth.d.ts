declare const _default: "\n\nvar uSceneDepthMap: texture_2d<f32>;\nvar uSceneDepthMapSampler: sampler;\n\n#ifndef SCREENSIZE\n    #define SCREENSIZE\n    uniform uScreenSize: vec4f;\n#endif\n\n#ifndef VIEWMATRIX\n    #define VIEWMATRIX\n    uniform matrix_view: mat4x4f;\n#endif\n\n#ifndef LINEARIZE_DEPTH\n    #define LINEARIZE_DEPTH\n\n    #ifndef CAMERAPLANES\n        #define CAMERAPLANES\n        uniform camera_params: vec4f; // x: 1 / camera_far,      y: camera_far,     z: camera_near,        w: is_ortho\n    #endif\n\n    fn linearizeDepth(z: f32) -> f32 {\n        if (uniform.camera_params.w == 0.0) { // Perspective\n            return (uniform.camera_params.z * uniform.camera_params.y) / (uniform.camera_params.y + z * (uniform.camera_params.z - uniform.camera_params.y));\n        } else {\n            return uniform.camera_params.z + z * (uniform.camera_params.y - uniform.camera_params.z);\n        }\n    }\n#endif\n\nfn delinearizeDepth(linearDepth: f32) -> f32 {\n    if (uniform.camera_params.w == 0.0) {\n        return (uniform.camera_params.y * (uniform.camera_params.z - linearDepth)) / (linearDepth * (uniform.camera_params.z - uniform.camera_params.y));\n    } else {\n        return (linearDepth - uniform.camera_params.z) / (uniform.camera_params.y - uniform.camera_params.z);\n    }\n}\n\n// Retrieves rendered linear camera depth by UV\nfn getLinearScreenDepth(uv: vec2f) -> f32 {\n    #ifdef SCENE_DEPTHMAP_LINEAR\n        #ifdef SCENE_DEPTHMAP_FLOAT\n            return textureSample(uSceneDepthMap, uSceneDepthMapSampler, uv).r;\n        #else\n\n            let textureSize = textureDimensions(uSceneDepthMap, 0);\n            let texel: vec2i = vec2i(uv * vec2f(textureSize));\n            let data: vec4f = textureLoad(uSceneDepthMap, texel, 0);\n\n            let data_u32: vec4u = vec4u(data * 255.0);\n            let intBits: u32 = (data_u32.r << 24u) | (data_u32.g << 16u) | (data_u32.b << 8u) | data_u32.a;\n\n            return bitcast<f32>(intBits);\n\n        #endif\n    #else\n        return linearizeDepth(textureSample(uSceneDepthMap, uSceneDepthMapSampler, uv).r);\n    #endif\n}\n\n#ifndef VERTEXSHADER\n    // Retrieves rendered linear camera depth under the current pixel\n    fn getLinearScreenDepthFrag() -> f32 {\n        let uv: vec2f = pcPosition.xy * uniform.uScreenSize.zw;\n        return getLinearScreenDepth(uv);\n    }\n#endif\n\n// Generates linear camera depth for the given world position\nfn getLinearDepth(pos: vec3f) -> f32 {\n    return -(uniform.matrix_view * vec4f(pos, 1.0)).z;\n}\n";
export default _default;
