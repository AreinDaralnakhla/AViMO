declare const _default: "\nstruct FaceCoords {\n    uv: vec2f,          // Original return value\n    faceIndex: f32,    // Was out parameter\n    tileOffset: vec2f, // Was out parameter\n}\n\n// Converts unnormalized direction vector to a cubemap face index [0..5] and uv coordinates within the face in [0..1] range.\n// Additionally offset to a tile in atlas within 3x3 subdivision is provided\nfn getCubemapFaceCoordinates(dir: vec3f) -> FaceCoords {\n    var faceIndex: f32;\n    var tileOffset: vec2f;\n    var uv: vec2f; // This is the face UV [0..1]\n    let vAbs: vec3f = abs(dir);\n    var ma: f32;\n\n    if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {   // front / back\n\n        let is_neg_z = dir.z < 0.0;\n        faceIndex = select(4.0, 5.0, is_neg_z);\n        ma = 0.5 / vAbs.z;\n        uv = vec2f(select(dir.x, -dir.x, is_neg_z), -dir.y);\n        tileOffset = vec2f(2.0, select(0.0, 1.0, is_neg_z));\n\n    } else if (vAbs.y >= vAbs.x) {  // top index 2, bottom index 3\n\n        let is_neg_y = dir.y < 0.0;\n        faceIndex = select(2.0, 3.0, is_neg_y);\n        ma = 0.5 / vAbs.y;\n        uv = vec2f(dir.x, select(dir.z, -dir.z, is_neg_y));\n        tileOffset = vec2f(1.0, select(0.0, 1.0, is_neg_y));\n\n    } else {    // left / right\n\n        let is_neg_x = dir.x < 0.0;\n        faceIndex = select(0.0, 1.0, is_neg_x);\n        ma = 0.5 / vAbs.x;\n        uv = vec2f(select(-dir.z, dir.z, is_neg_x), -dir.y);\n        tileOffset = vec2f(0.0, select(0.0, 1.0, is_neg_x));\n    }\n\n    uv = uv * ma + 0.5;\n    return FaceCoords(uv, faceIndex, tileOffset);\n}\n\n// converts unnormalized direction vector to a texture coordinate for a cubemap face stored within texture atlas described by the viewport\nfn getCubemapAtlasCoordinates(omniAtlasViewport: vec3f, shadowEdgePixels: f32, shadowTextureResolution: f32, dir: vec3f) -> vec2f {\n\n    let faceData: FaceCoords = getCubemapFaceCoordinates(dir);\n    var uv: vec2f = faceData.uv;\n    let tileOffset: vec2f = faceData.tileOffset;\n\n    // move uv coordinates inwards inside to compensate for larger fov when rendering shadow into atlas\n    let atlasFaceSize: f32 = omniAtlasViewport.z;\n    let tileSize: f32 = shadowTextureResolution * atlasFaceSize;\n    var offset: f32 = shadowEdgePixels / tileSize;\n    uv = uv * (1.0 - offset * 2.0) + offset;\n\n    // scale uv coordinates to cube face area within the viewport\n    uv = uv * atlasFaceSize;\n\n    // offset into face of the atlas (3x3 grid)\n    uv = uv + tileOffset * atlasFaceSize;\n\n    // offset into the atlas viewport\n    uv = uv + omniAtlasViewport.xy;\n\n    return uv;\n}\n";
export default _default;
