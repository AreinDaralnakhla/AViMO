declare const _default: "\nvar texture_msdfMap: texture_2d<f32>;\nvar texture_msdfMapSampler: sampler;\n\nfn median(r: f32, g: f32, b: f32) -> f32 {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfn map(min: f32, max: f32, v: f32) -> f32 {\n    return (v - min) / (max - min);\n}\n\nuniform font_sdfIntensity: f32; // intensity is used to boost the value read from the SDF, 0 is no boost, 1.0 is max boost\nuniform font_pxrange: f32;      // the number of pixels between inside and outside the font in SDF\nuniform font_textureWidth: f32; // the width of the texture atlas\n\n#ifndef LIT_MSDF_TEXT_ATTRIBUTE\n    uniform outline_color: vec4f;\n    uniform outline_thickness: f32;\n    uniform shadow_color: vec4f;\n    uniform shadow_offset: vec2f;\n#else\n    varying outline_color: vec4f;\n    varying outline_thickness: f32;\n    varying shadow_color: vec4f;\n    varying shadow_offset: vec2f;\n#endif\n\nfn applyMsdf(color_in: vec4f) -> vec4f {\n\n    #ifndef LIT_MSDF_TEXT_ATTRIBUTE\n        var outline_colorValue = uniform.outline_color;\n        var outline_thicknessValue = uniform.outline_thickness;\n        var shadow_colorValue = uniform.shadow_color;\n        var shadow_offsetValue = uniform.shadow_offset;\n    #else\n        var outline_colorValue = outline_color;\n        var outline_thicknessValue = outline_thickness;\n        var shadow_colorValue = shadow_color;\n        var shadow_offsetValue = shadow_offset;\n    #endif\n\n    // Convert to linear space before processing\n    // TODO: ideally this would receive the color in linear space, but that would require larger changes\n    // on the engine side, with the way premultiplied alpha is handled as well.\n    var color = vec4f(gammaCorrectInputVec3(color_in.rgb), color_in.a);\n\n    // sample the field\n    let tsample: vec3f = textureSample(texture_msdfMap, texture_msdfMapSampler, vUv0).rgb;\n    let uvShdw: vec2f = vUv0 - shadow_offsetValue;\n    let ssample: vec3f = textureSample(texture_msdfMap, texture_msdfMapSampler, uvShdw).rgb;\n\n    // get the signed distance value\n    let sigDist: f32 = median(tsample.r, tsample.g, tsample.b);\n    var sigDistShdw: f32 = median(ssample.r, ssample.g, ssample.b);\n\n    // smoothing limit - smaller value makes for sharper but more aliased text, especially on angles\n    // too large value (0.5) creates a dark glow around the letters\n    let smoothingMax: f32 = 0.2;\n\n    // smoothing depends on size of texture on screen\n    let w: vec2f = abs(dpdx(vUv0)) + abs(dpdy(vUv0));\n    let smoothing: f32 = clamp(w.x * uniform.font_textureWidth / uniform.font_pxrange, 0.0, smoothingMax);\n\n    let mapMin: f32 = 0.05;\n    let mapMax: f32 = clamp(1.0 - uniform.font_sdfIntensity, mapMin, 1.0);\n\n    // remap to a smaller range (used on smaller font sizes)\n    let sigDistInner: f32 = map(mapMin, mapMax, sigDist);\n    let sigDistOutline: f32 = map(mapMin, mapMax, sigDist + outline_thicknessValue);\n    sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thicknessValue);\n\n    let center: f32 = 0.5;\n    // calculate smoothing and use to generate opacity\n    let inside: f32 = smoothstep(center - smoothing, center + smoothing, sigDistInner);\n    let outline: f32 = smoothstep(center - smoothing, center + smoothing, sigDistOutline);\n    let shadow: f32 = smoothstep(center - smoothing, center + smoothing, sigDistShdw);\n\n    let tcolor_outline: vec4f = outline * vec4f(outline_colorValue.a * outline_colorValue.rgb, outline_colorValue.a);\n    var tcolor: vec4f = select(vec4f(0.0), tcolor_outline, outline > inside);\n    tcolor = mix(tcolor, color, inside);\n\n    let scolor_shadow: vec4f = shadow * vec4f(shadow_colorValue.a * shadow_colorValue.rgb, shadow_colorValue.a);\n    let scolor: vec4f = select(tcolor, scolor_shadow, shadow > outline);\n    tcolor = mix(scolor, tcolor, outline);\n\n    // Convert back to gamma space before returning\n    tcolor = vec4f(gammaCorrectOutput(tcolor.rgb), tcolor.a);\n\n    return tcolor;\n}\n";
export default _default;
