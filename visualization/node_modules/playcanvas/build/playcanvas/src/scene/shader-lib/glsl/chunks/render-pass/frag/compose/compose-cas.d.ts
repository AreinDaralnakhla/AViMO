declare const _default: "\n    #ifdef CAS\n        uniform float sharpness;\n\n        // reversible LDR <-> HDR tone mapping, as CAS needs LDR input\n        float maxComponent(float x, float y, float z) { return max(x, max(y, z)); }\n        vec3 toSDR(vec3 c) { return c / (1.0 + maxComponent(c.r, c.g, c.b)); }\n        vec3 toHDR(vec3 c) { return c / (1.0 - maxComponent(c.r, c.g, c.b)); }\n\n        vec3 applyCas(vec3 color, vec2 uv, float sharpness) {\n            float x = sceneTextureInvRes.x;\n            float y = sceneTextureInvRes.y;\n\n            // sample 4 neighbors around the already sampled pixel, and convert it to SDR\n            vec3 a = toSDR(texture2DLod(sceneTexture, uv + vec2(0.0, -y), 0.0).rgb);\n            vec3 b = toSDR(texture2DLod(sceneTexture, uv + vec2(-x, 0.0), 0.0).rgb);\n            vec3 c = toSDR(color.rgb);\n            vec3 d = toSDR(texture2DLod(sceneTexture, uv + vec2(x, 0.0), 0.0).rgb);\n            vec3 e = toSDR(texture2DLod(sceneTexture, uv + vec2(0.0, y), 0.0).rgb);\n\n            // apply the sharpening\n            float min_g = min(a.g, min(b.g, min(c.g, min(d.g, e.g))));\n            float max_g = max(a.g, max(b.g, max(c.g, max(d.g, e.g))));\n            float sharpening_amount = sqrt(min(1.0 - max_g, min_g) / max_g);\n            float w = sharpening_amount * sharpness;\n            vec3 res = (w * (a + b + d + e) + c) / (4.0 * w + 1.0);\n\n            // remove negative colors\n            res = max(res, 0.0);\n\n            // convert back to HDR\n            return toHDR(res);\n        }\n    #endif\n";
export default _default;
