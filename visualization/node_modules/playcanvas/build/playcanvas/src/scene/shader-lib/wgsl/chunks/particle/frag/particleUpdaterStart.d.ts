declare const _default: "\nfn saturate(x: f32) -> f32 {\n    return clamp(x, 0.0, 1.0);\n}\n\nfn unpack3NFloats(src: f32) -> vec3f {\n    let r = fract(src);\n    let g = fract(src * 256.0);\n    let b = fract(src * 65536.0);\n    return vec3f(r, g, b);\n}\n\n// Struct to handle multiple return values from tex1Dlod_lerp\nstruct TexLerpUnpackResult {\n    result: vec3f,\n    unpacked: vec3f\n}\n\nfn tex1Dlod_lerp(tex: texture_2d<f32>, texSampler: sampler, tc: vec2f) -> TexLerpUnpackResult {\n    let tc_next = tc + vec2f(uniform.graphSampleSize);\n    let a = textureSampleLevel(tex, texSampler, tc, 0.0);\n    let b = textureSampleLevel(tex, texSampler, tc_next, 0.0);\n    let c = fract(tc.x * uniform.graphNumSamples);\n\n    let unpackedA = unpack3NFloats(a.w);\n    let unpackedB = unpack3NFloats(b.w);\n    let w_out = mix(unpackedA, unpackedB, c);\n\n    return TexLerpUnpackResult(mix(a.xyz, b.xyz, c), w_out);\n}\n\nconst HASHSCALE4: vec4f = vec4f(1031.0, 0.1030, 0.0973, 0.1099);\nfn hash41(p: f32) -> vec4f {\n    var p4 = fract(vec4f(p) * HASHSCALE4);\n    p4 = p4 + dot(p4, p4.wzxy + 19.19);\n    return fract(vec4f((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n@fragment\nfn fragmentMain(input : FragmentInput) -> FragmentOutput {\n    var output: FragmentOutput;\n\n    if (pcPosition.x > uniform.numParticles) {\n        discard;\n        return output;\n    }\n\n    readInput(input.vUv0.x);\n    visMode = select(-1.0, 1.0, inShow);\n\n    let rndFactor = hash41(pcPosition.x + uniform.seed);\n\n    let particleRate = uniform.rate + uniform.rateDiv * rndFactor.x;\n\n    outLife = inLife + uniform.delta;\n    let nlife = clamp(outLife / uniform.lifetime, 0.0, 1.0);\n\n    let lerpResult0 = tex1Dlod_lerp(internalTex0, internalTex0Sampler, vec2f(nlife, 0.0));\n    var localVelocity = lerpResult0.result;\n    let localVelocityDiv = lerpResult0.unpacked;\n\n    let lerpResult1 = tex1Dlod_lerp(internalTex1, internalTex1Sampler, vec2f(nlife, 0.0));\n    var velocity = lerpResult1.result;\n    let velocityDiv = lerpResult1.unpacked;\n\n    let lerpResult2 = tex1Dlod_lerp(internalTex2, internalTex2Sampler, vec2f(nlife, 0.0));\n    let params = lerpResult2.result;\n    let paramDiv = lerpResult2.unpacked;\n    var rotSpeed = params.x;\n    let rotSpeedDiv = paramDiv.y;\n\n    let lerpResult3 = tex1Dlod_lerp(internalTex3, internalTex3Sampler, vec2f(nlife, 0.0));\n    let radialParams = lerpResult3.result;\n    let radialParamDiv = lerpResult3.unpacked;\n    let radialSpeed = radialParams.x;\n    let radialSpeedDiv = radialParamDiv.y;\n\n    let respawn = inLife <= 0.0 || outLife >= uniform.lifetime;\n    inPos = select(inPos, calcSpawnPosition(rndFactor.xyz, rndFactor.x), respawn);\n    inAngle = select(inAngle, mix(uniform.startAngle, uniform.startAngle2, rndFactor.x), respawn);\n\n    #ifndef LOCAL_SPACE\n        var radialVel: vec3f = inPos - uniform.emitterPos;\n    #else\n        var radialVel: vec3f = inPos;\n    #endif\n    radialVel = select(vec3f(0.0), radialSpeed * normalize(radialVel), dot(radialVel, radialVel) > 1.0E-8);\n    radialVel = radialVel + (radialSpeedDiv * vec3f(2.0) - vec3f(1.0)) * uniform.radialSpeedDivMult * rndFactor.xyz;\n\n    localVelocity = localVelocity + (localVelocityDiv * vec3f(2.0) - vec3f(1.0)) * uniform.localVelocityDivMult * rndFactor.xyz;\n    velocity = velocity + (velocityDiv * vec3f(2.0) - vec3f(1.0)) * uniform.velocityDivMult * rndFactor.xyz;\n    rotSpeed = rotSpeed + (rotSpeedDiv * 2.0 - 1.0) * uniform.rotSpeedDivMult * rndFactor.y;\n\n    addInitialVelocity(&localVelocity, rndFactor.xyz);\n\n    #ifndef LOCAL_SPACE\n        outVel = uniform.emitterMatrix * localVelocity + (radialVel + velocity) * uniform.emitterScale;\n    #else\n        outVel = (localVelocity + radialVel) / uniform.emitterScale + uniform.emitterMatrixInv * velocity;\n    #endif\n\n    outPos = inPos + outVel * uniform.delta;\n    outAngle = inAngle + rotSpeed * uniform.delta;\n";
export default _default;
