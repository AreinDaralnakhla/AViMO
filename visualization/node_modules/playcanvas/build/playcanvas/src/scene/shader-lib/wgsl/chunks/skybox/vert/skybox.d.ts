declare const _default: "\n    // Attribute\n    attribute aPosition : vec4f;\n\n    uniform matrix_view : mat4x4f;\n    uniform matrix_projectionSkybox : mat4x4f;\n    uniform cubeMapRotationMatrix : mat3x3f;\n\n    varying vViewDir : vec3f;\n\n    #ifdef PREPASS_PASS\n        // when skydome renders depth during prepass, generate linear depth\n        varying vLinearDepth: f32;\n    #endif\n\n    #ifdef SKYMESH\n        uniform matrix_model : mat4x4f;\n        varying vWorldPos : vec3f;\n    #endif\n\n    @vertex\n    fn vertexMain(input : VertexInput) -> VertexOutput {\n\n        var output : VertexOutput;\n        var view : mat4x4f = uniform.matrix_view;\n\n        #ifdef SKYMESH\n\n            var worldPos : vec4f = uniform.matrix_model * input.aPosition;\n            output.vWorldPos = worldPos.xyz;\n            output.position = uniform.matrix_projectionSkybox * (view * worldPos);\n\n            #ifdef PREPASS_PASS\n                // linear depth from the worldPosition, see getLinearDepth\n                output.vLinearDepth = -(uniform.matrix_view * vec4f(worldPos.xyz, 1.0)).z;\n            #endif\n\n        #else\n\n            view[3][0] = 0.0;\n            view[3][1] = 0.0;\n            view[3][2] = 0.0;\n            output.position = uniform.matrix_projectionSkybox * (view * input.aPosition);\n            output.vViewDir = input.aPosition.xyz * uniform.cubeMapRotationMatrix;\n\n            #ifdef PREPASS_PASS\n                // for infinite skybox, use negative gl_Position.w to get positive linear depth\n                output.vLinearDepth = -pcPosition.w;\n            #endif\n        #endif\n\n        // Force skybox to far Z, regardless of the clip planes on the camera\n        // Subtract a tiny fudge factor to ensure floating point errors don't\n        // still push pixels beyond far Z. See:\n        // https://community.khronos.org/t/skybox-problem/61857\n\n        output.position.z = output.position.w - 1.0e-7;\n\n        return output;\n    }\n";
export default _default;
