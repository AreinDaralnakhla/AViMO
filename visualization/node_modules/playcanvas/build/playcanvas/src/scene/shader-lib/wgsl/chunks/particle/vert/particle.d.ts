declare const _default: "\nfn unpack3NFloats(src: f32) -> vec3f {\n    let r = fract(src);\n    let g = fract(src * 256.0);\n    let b = fract(src * 65536.0);\n    return vec3f(r, g, b);\n}\n\nfn saturate(x: f32) -> f32 {\n    return clamp(x, 0.0, 1.0);\n}\n\nstruct TexLerpUnpackResult {\n    result: vec4f,\n    unpacked: vec3f\n}\n\nfn tex1Dlod_lerp_simple(tex: texture_2d<f32>, texSampler: sampler, tc: vec2f) -> vec4f {\n    let tc_next = tc + vec2f(uniform.graphSampleSize);\n    return mix( textureSample(tex, texSampler, tc), textureSample(tex, texSampler, tc_next), fract(tc.x * uniform.graphNumSamples) );\n}\n\nfn tex1Dlod_lerp_unpack(tex: texture_2d<f32>, texSampler: sampler, tc: vec2f) -> TexLerpUnpackResult {\n    let tc_next = tc + vec2f(uniform.graphSampleSize);\n    let a = textureSampleLevel(tex, texSampler, tc, 0.0);\n    let b = textureSampleLevel(tex, texSampler, tc_next, 0.0);\n    let c = fract(tc.x * uniform.graphNumSamples);\n    let unpackedA = unpack3NFloats(a.w);\n    let unpackedB = unpack3NFloats(b.w);\n    let w_out = mix(unpackedA, unpackedB, c);\n    return TexLerpUnpackResult(mix(a, b, c), w_out);\n}\n\nstruct RotateResult {\n    rotatedVec: vec2f,\n    matrix: mat2x2f\n}\n\nfn rotateWithMatrix(quadXY: vec2f, pRotation: f32) -> RotateResult {\n    let c = cos(pRotation);\n    let s = sin(pRotation);\n    let m = mat2x2f(vec2f(c, s), vec2f(-s, c));\n    return RotateResult(m * quadXY, m);\n}\n\nfn billboard(InstanceCoords: vec3f, quadXY: vec2f) -> vec3f {\n    var pos: vec3f;\n    #ifdef SCREEN_SPACE\n        pos = vec3f(-1.0, 0.0, 0.0) * quadXY.x + vec3f(0.0, -1.0, 0.0) * quadXY.y;\n    #else\n        pos = -uniform.matrix_viewInverse[0].xyz * quadXY.x + -uniform.matrix_viewInverse[1].xyz * quadXY.y;\n    #endif\n    return pos;\n}\n\nfn customFace(InstanceCoords: vec3f, quadXY: vec2f) -> vec3f {\n    let pos = uniform.faceTangent * quadXY.x + uniform.faceBinorm * quadXY.y;\n    return pos;\n}\n\nfn safeNormalize(v: vec2f) -> vec2f {\n    let l = length(v);\n    return select(v, v / l, l > 1e-06);\n}\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n    var output: VertexOutput;\n\n    let meshLocalPos_in = input.particle_vertexData.xyz;\n    let id = floor(input.particle_vertexData.w);\n\n    let rndFactor = fract(sin(id + 1.0 + uniform.seed));\n    let rndFactor3 = vec3f(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\n    let uv = id / uniform.numParticlesPot;\n    readInput(uv);\n\n    #ifdef LOCAL_SPACE\n        let modelRotation = mat3x3f(uniform.matrix_model[0].xyz, uniform.matrix_model[1].xyz, uniform.matrix_model[2].xyz);\n        inVel = modelRotation * inVel;\n    #endif\n    let viewRotation = mat3x3f(uniform.matrix_view[0].xyz, uniform.matrix_view[1].xyz, uniform.matrix_view[2].xyz);\n    let velocityV = safeNormalize((viewRotation * inVel).xy);\n\n    let particleLifetime = uniform.lifetime;\n\n    var meshLocalPos = meshLocalPos_in;\n    if (inLife <= 0.0 || inLife > particleLifetime || !inShow) {\n         meshLocalPos = vec3f(0.0);\n    }\n    let quadXY = meshLocalPos.xy;\n    let nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\n    let lerp_result = tex1Dlod_lerp_unpack(internalTex2, internalTex2Sampler, vec2f(nlife, 0.0));\n    let params = lerp_result.result;\n    let paramDiv = lerp_result.unpacked;\n\n    var scale = params.y;\n    let scaleDiv = paramDiv.x;\n    let alphaDiv = paramDiv.z;\n\n    scale = scale + (scaleDiv * 2.0 - 1.0) * uniform.scaleDivMult * fract(rndFactor*10000.0);\n\n    #ifndef USE_MESH\n        output.texCoordsAlphaLife = vec4f(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * uniform.alphaDivMult * fract(rndFactor*1000.0), nlife);\n    #else\n        output.texCoordsAlphaLife = vec4f(particle_uv, (alphaDiv * 2.0 - 1.0) * uniform.alphaDivMult * fract(rndFactor*1000.0), nlife);\n    #endif\n\n    var particlePos = inPos;\n    var particlePosMoved = vec3f(0.0);\n\n    var rotMatrix: mat2x2f;\n";
export default _default;
