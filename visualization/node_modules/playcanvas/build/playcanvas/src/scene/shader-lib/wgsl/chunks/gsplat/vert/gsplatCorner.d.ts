declare const _default: "\nuniform viewport: vec2f;                  // viewport dimensions\nuniform camera_params: vec4f;             // 1 / far, far, near, isOrtho\n\n// calculate the clip-space offset from the center for this gaussian\nfn initCorner(source: ptr<function, SplatSource>, center: ptr<function, SplatCenter>, corner: ptr<function, SplatCorner>) -> bool {\n    // get covariance\n    var covA: vec3f;\n    var covB: vec3f;\n    readCovariance(source, &covA, &covB);\n\n    let Vrk = mat3x3f(\n        vec3f(covA.x, covA.y, covA.z),\n        vec3f(covA.y, covB.x, covB.y),\n        vec3f(covA.z, covB.y, covB.z)\n    );\n\n    let focal = uniform.viewport.x * center.projMat00;\n\n    let v = select(center.view.xyz, vec3f(0.0, 0.0, 1.0), uniform.camera_params.w == 1.0);\n    let J1 = focal / v.z;\n    let J2 = -J1 / v.z * v.xy;\n    let J = mat3x3f(\n        vec3f(J1, 0.0, J2.x),\n        vec3f(0.0, J1, J2.y),\n        vec3f(0.0, 0.0, 0.0)\n    );\n\n    let W = transpose(mat3x3f(center.modelView[0].xyz, center.modelView[1].xyz, center.modelView[2].xyz));\n    let T = W * J;\n    let cov = transpose(T) * Vrk * T;\n\n    #if GSPLAT_AA\n        // calculate AA factor\n        let detOrig = cov[0][0] * cov[1][1] - cov[0][1] * cov[1][0]; // Using [0][1] * [1][0] as matrix might not be perfectly symmetric numerically\n        let detBlur = (cov[0][0] + 0.3) * (cov[1][1] + 0.3) - cov[0][1] * cov[1][0];\n        corner.aaFactor = sqrt(detOrig / detBlur);\n    #endif\n\n    let diagonal1 = cov[0][0] + 0.3;\n    let offDiagonal = cov[0][1];\n    let diagonal2 = cov[1][1] + 0.3;\n\n    let mid = 0.5 * (diagonal1 + diagonal2);\n    let radius = length(vec2f((diagonal1 - diagonal2) / 2.0, offDiagonal));\n    let lambda1 = mid + radius;\n    let lambda2 = max(mid - radius, 0.1);\n\n    // Use the smaller viewport dimension to limit the kernel size relative to the screen resolution.\n    let vmin = min(1024.0, min(uniform.viewport.x, uniform.viewport.y));\n\n    let l1 = 2.0 * min(sqrt(2.0 * lambda1), vmin);\n    let l2 = 2.0 * min(sqrt(2.0 * lambda2), vmin);\n\n    // early-out gaussians smaller than 2 pixels\n    if (l1 < 2.0 && l2 < 2.0) {\n        return false;\n    }\n\n    let c = center.proj.ww / uniform.viewport;\n\n    // cull against frustum x/y axes\n    if (any((abs(center.proj.xy) - vec2f(max(l1, l2)) * c) > center.proj.ww)) {\n        return false;\n    }\n\n    let diagonalVector = normalize(vec2f(offDiagonal, lambda1 - diagonal1));\n    let v1 = l1 * diagonalVector;\n    let v2 = l2 * vec2f(diagonalVector.y, -diagonalVector.x); // Swizzle\n\n    corner.offset = (source.cornerUV.x * v1 + source.cornerUV.y * v2) * c;\n    corner.uv = source.cornerUV;\n\n    return true;\n}\n";
export default _default;
