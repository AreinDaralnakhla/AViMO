declare const _default: "\n#if defined(NEAR_BLUR)\n    var nearTexture: texture_2d<f32>;\n    var nearTextureSampler: sampler;\n#endif\nvar farTexture: texture_2d<f32>;\nvar farTextureSampler: sampler;\nvar cocTexture: texture_2d<f32>;\nvar cocTextureSampler: sampler;\n\nuniform kernel: array<vec2f, {KERNEL_COUNT}>;\nuniform blurRadiusNear: f32;\nuniform blurRadiusFar: f32;\n\nvarying uv0: vec2f;\n\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n    var output: FragmentOutput;\n\n    let coc: vec2f = textureSample(cocTexture, cocTextureSampler, input.uv0).rg;\n    let cocFar: f32 = coc.r;\n\n    var sum: vec3f = vec3f(0.0, 0.0, 0.0);\n\n    #if defined(NEAR_BLUR)\n        // near blur\n        let cocNear: f32 = coc.g;\n        if (cocNear > 0.0001) {\n            let nearTextureSize: vec2f = vec2f(textureDimensions(nearTexture, 0));\n            let step: vec2f = cocNear * uniform.blurRadiusNear / nearTextureSize;\n\n            for (var i: i32 = 0; i < {KERNEL_COUNT}; i = i + 1) {\n                let uv: vec2f = uv0 + step * uniform.kernel[i].element;\n                let tap: vec3f = textureSampleLevel(nearTexture, nearTextureSampler, uv, 0.0).rgb;\n                sum = sum + tap;\n            }\n            sum = sum * f32({INV_KERNEL_COUNT});\n\n        } else\n    #endif\n\n        if (cocFar > 0.0001) { // far blur\n\n            let farTextureSize: vec2f = vec2f(textureDimensions(farTexture, 0));\n            let step: vec2f = cocFar * uniform.blurRadiusFar / farTextureSize;\n\n            var sumCoC: f32 = 0.0;\n            for (var i: i32 = 0; i < {KERNEL_COUNT}; i = i + 1) {\n                let uv: vec2f = uv0 + step * uniform.kernel[i].element;\n                var tap: vec3f = textureSampleLevel(farTexture, farTextureSampler, uv, 0.0).rgb;\n\n                // block out sharp objects to avoid leaking to far blur\n                let cocThis: f32 = textureSampleLevel(cocTexture, cocTextureSampler, uv, 0.0).r;\n                tap = tap * cocThis;\n                sumCoC = sumCoC + cocThis;\n\n                sum = sum + tap;\n            }\n\n            // average out the sum\n            if (sumCoC > 0.0) {\n                sum = sum / sumCoC;\n            }\n\n            // compensate for the fact the farTexture was premultiplied by CoC\n            sum = sum / cocFar;\n        }\n\n    output.color = vec4f(sum, 1.0);\n    return output;\n}\n";
export default _default;
