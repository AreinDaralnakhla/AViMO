declare const _default: "\n    #ifdef CAS\n        uniform sharpness: f32;\n\n        // reversible LDR <-> HDR tone mapping, as CAS needs LDR input\n        fn maxComponent(x: f32, y: f32, z: f32) -> f32 { return max(x, max(y, z)); }\n        fn toSDR(c: vec3f) -> vec3f { return c / (1.0 + maxComponent(c.r, c.g, c.b)); }\n        fn toHDR(c: vec3f) -> vec3f { return c / (1.0 - maxComponent(c.r, c.g, c.b)); }\n\n        fn applyCas(color: vec3f, uv: vec2f, sharpness: f32) -> vec3f {\n            let x = uniform.sceneTextureInvRes.x;\n            let y = uniform.sceneTextureInvRes.y;\n\n            // sample 4 neighbors around the already sampled pixel, and convert it to SDR\n            let a = toSDR(textureSampleLevel(sceneTexture, sceneTextureSampler, uv + vec2f(0.0, -y), 0.0).rgb);\n            let b = toSDR(textureSampleLevel(sceneTexture, sceneTextureSampler, uv + vec2f(-x, 0.0), 0.0).rgb);\n            let c = toSDR(color.rgb);\n            let d = toSDR(textureSampleLevel(sceneTexture, sceneTextureSampler, uv + vec2f(x, 0.0), 0.0).rgb);\n            let e = toSDR(textureSampleLevel(sceneTexture, sceneTextureSampler, uv + vec2f(0.0, y), 0.0).rgb);\n\n            // apply the sharpening\n            let min_g = min(a.g, min(b.g, min(c.g, min(d.g, e.g))));\n            let max_g = max(a.g, max(b.g, max(c.g, max(d.g, e.g))));\n            let sharpening_amount = sqrt(min(1.0 - max_g, min_g) / max_g);\n            let w = sharpening_amount * uniform.sharpness;\n            var res = (w * (a + b + d + e) + c) / (4.0 * w + 1.0);\n\n            // remove negative colors\n            res = max(res, vec3f(0.0));\n\n            // convert back to HDR\n            return toHDR(res);\n        }\n    #endif\n";
export default _default;
