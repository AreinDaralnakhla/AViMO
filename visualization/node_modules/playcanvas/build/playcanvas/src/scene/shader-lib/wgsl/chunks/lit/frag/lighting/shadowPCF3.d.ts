declare const _default: "\n// ----- Directional/Spot Sampling -----\nfn _getShadowPCF3x3(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec3f) -> f32 {\n    let z: f32 = shadowCoord.z;\n    let uv: vec2f = shadowCoord.xy * shadowParams.x; // 1 unit - 1 texel\n    let shadowMapSizeInv: f32 = 1.0 / shadowParams.x;\n    let base_uv_temp: vec2f = floor(uv + 0.5);\n    let s: f32 = (uv.x + 0.5 - base_uv_temp.x);\n    let t: f32 = (uv.y + 0.5 - base_uv_temp.y);\n    let base_uv: vec2f = (base_uv_temp - vec2f(0.5)) * shadowMapSizeInv;\n\n    var sum: f32 = 0.0;\n\n    let uw0: f32 = (3.0 - 2.0 * s);\n    let uw1: f32 = (1.0 + 2.0 * s);\n\n    let u0_offset: f32 = (2.0 - s) / uw0 - 1.0;\n    let u1_offset: f32 = s / uw1 + 1.0;\n\n    let vw0: f32 = (3.0 - 2.0 * t);\n    let vw1: f32 = (1.0 + 2.0 * t);\n\n    let v0_offset: f32 = (2.0 - t) / vw0 - 1.0;\n    let v1_offset: f32 = t / vw1 + 1.0;\n\n    let u0: f32 = u0_offset * shadowMapSizeInv + base_uv.x;\n    let v0: f32 = v0_offset * shadowMapSizeInv + base_uv.y;\n\n    let u1: f32 = u1_offset * shadowMapSizeInv + base_uv.x;\n    let v1: f32 = v1_offset * shadowMapSizeInv + base_uv.y;\n\n    sum = sum + uw0 * vw0 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u0, v0), z);\n    sum = sum + uw1 * vw0 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u1, v0), z);\n    sum = sum + uw0 * vw1 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u0, v1), z);\n    sum = sum + uw1 * vw1 * textureSampleCompareLevel(shadowMap, shadowMapSampler, vec2f(u1, v1), z);\n\n    sum = sum * (1.0 / 16.0);\n    return sum;\n}\n\nfn getShadowPCF3x3(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {\n    return _getShadowPCF3x3(shadowMap, shadowMapSampler, shadowCoord, shadowParams.xyz);\n}\n\nfn getShadowSpotPCF3x3(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {\n    return _getShadowPCF3x3(shadowMap, shadowMapSampler, shadowCoord, shadowParams.xyz);\n}\n\n// ----- Omni Sampling -----\n\n// Not currently supported on WebGPU device\n// fn getShadowOmniPCF3x3(shadowMap: texture_depth_cube, shadowMapSampler: sampler_comparison, shadowParams: vec4f, dir: vec3f) -> f32 {\n\n//     // Calculate shadow depth from the light direction\n//     let shadowZ: f32 = length(dir) * shadowParams.w + shadowParams.z;\n\n//     // offset\n//     let texSize_i = textureDimensions(shadowMap, 0);\n//     let z: f32 = 1.0 / f32(texSize_i.x);\n//     let tc: vec3f = normalize(dir);\n\n//     // average 4 samples - not a strict 3x3 PCF but that's tricky with cubemaps\n//     var shadows: vec4f;\n//     shadows.x = textureSampleCompareLevel(shadowMap, shadowMapSampler, tc + vec3f( z,  z,  z), shadowZ);\n//     shadows.y = textureSampleCompareLevel(shadowMap, shadowMapSampler, tc + vec3f(-z, -z,  z), shadowZ);\n//     shadows.z = textureSampleCompareLevel(shadowMap, shadowMapSampler, tc + vec3f(-z,  z, -z), shadowZ);\n//     shadows.w = textureSampleCompareLevel(shadowMap, shadowMapSampler, tc + vec3f( z, -z, -z), shadowZ);\n\n//     return dot(shadows, vec4f(0.25));\n// }\n\n// fn getShadowOmniPCF3x3_Wrapper(shadowMap: texture_depth_cube, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f, lightDir: vec3f) -> f32 {\n//     return getShadowOmniPCF3x3(shadowMap, shadowMapSampler, shadowParams, lightDir);\n// }\n";
export default _default;
