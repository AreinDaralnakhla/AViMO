declare const _default: "\n\n// shadow casting functionality\n#ifdef LIGHT{i}CASTSHADOW\n\n    // generate shadow coordinates function, based on per light defines:\n    // - _SHADOW_SAMPLE_NORMAL_OFFSET\n    // - _SHADOW_SAMPLE_ORTHO\n    // - _SHADOW_SAMPLE_POINT\n    // - _SHADOW_SAMPLE_SOURCE_ZBUFFER\n    vec3 getShadowSampleCoord{i}(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n\n        vec3 surfacePosition = worldPosition;\n\n        #ifdef LIGHT{i}_SHADOW_SAMPLE_POINT\n            #ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n                float distScale = length(lightDir);\n                surfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n                lightDir = surfacePosition - lightPos;\n                return lightDir;\n            #endif\n        #else\n            #ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER\n                #ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n                    surfacePosition = surfacePosition + normal * shadowParams.y;\n                #endif\n            #else\n                #ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n                    #ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO\n                        float distScale = 1.0;\n                    #else\n                        float distScale = abs(dot(vPositionW - lightPos, lightDirNorm));\n                    #endif\n                    surfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n                #endif\n            #endif\n\n            vec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);\n            #ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO\n                positionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;\n            #else\n                #ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER\n                    positionInShadowSpace.xyz /= positionInShadowSpace.w;\n                #else\n                    positionInShadowSpace.xy /= positionInShadowSpace.w;\n                    positionInShadowSpace.z = length(lightDir) * shadowParams.w;\n                #endif\n            #endif\n\n            // this is currently unused\n            #ifdef SHADOW_SAMPLE_Z_BIAS\n                // positionInShadowSpace.z += getShadowBias(shadowParams.x, shadowParams.z);\n            #endif\n            surfacePosition = positionInShadowSpace.xyz;\n        #endif\n\n        return surfacePosition;\n    }\n\n    // shadow evaluation function\n    float getShadow{i}(vec3 lightDirW) {\n\n        // directional shadow cascades\n        #ifdef LIGHT{i}_SHADOW_CASCADES\n\n            // select shadow cascade matrix\n            int cascadeIndex = getShadowCascadeIndex(light{i}_shadowCascadeDistances, light{i}_shadowCascadeCount);\n\n            #ifdef LIGHT{i}_SHADOW_CASCADE_BLEND\n                cascadeIndex = ditherShadowCascadeIndex(cascadeIndex, light{i}_shadowCascadeDistances, light{i}_shadowCascadeCount, light{i}_shadowCascadeBlend);\n            #endif\n\n            mat4 shadowMatrix = light{i}_shadowMatrixPalette[cascadeIndex];\n\n        #else\n\n            mat4 shadowMatrix = light{i}_shadowMatrix;\n\n        #endif\n\n        #if LIGHT{i}TYPE == DIRECTIONAL\n            // directional light does not have a position\n            vec3 shadowCoord = getShadowSampleCoord{i}(shadowMatrix, light{i}_shadowParams, vPositionW, vec3(0.0), lightDirW, dLightDirNormW, dVertexNormalW);\n        #else\n            vec3 shadowCoord = getShadowSampleCoord{i}(shadowMatrix, light{i}_shadowParams, vPositionW, light{i}_position, lightDirW, dLightDirNormW, dVertexNormalW);\n        #endif\n\n        // Fade directional shadow at the far distance\n        #if LIGHT{i}TYPE == DIRECTIONAL\n            shadowCoord = fadeShadow(shadowCoord, light{i}_shadowCascadeDistances);\n        #endif\n\n        // ----- sample the shadow -----\n\n        #if LIGHT{i}TYPE == DIRECTIONAL // ----- directional light -----\n\n            #if LIGHT{i}SHADOWTYPE == VSM_16F\n                return getShadowVSM16(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 5.54);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == VSM_32F\n                return getShadowVSM32(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 15.0);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCSS_32F\n\n                #if LIGHT{i}SHAPE != PUNCTUAL\n                    vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;\n                    return getShadowPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);\n                #else\n                    return getShadowPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, light{i}_softShadowParams, lightDirW);\n                #endif\n\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n                return getShadowPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n                return getShadowPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F\n                return getShadowPCF5x5(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n            #endif\n\n        #endif\n\n\n        #if LIGHT{i}TYPE == SPOT // ----- spot light -----\n\n            #if LIGHT{i}SHADOWTYPE == VSM_16F\n                return getShadowSpotVSM16(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 5.54, lightDirW);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == VSM_32F\n                return getShadowSpotVSM32(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 15.0, lightDirW);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCSS_32F\n\n                #if LIGHT{i}SHAPE != PUNCTUAL\n                    vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;\n                #else\n                    vec2 shadowSearchArea = vec2(light{i}_shadowSearchArea);\n                #endif\n\n                return getShadowSpotPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);\n\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n                return getShadowSpotPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n                return getShadowSpotPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F\n                return getShadowSpotPCF5x5(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n            #endif\n\n        #endif\n\n\n        #if LIGHT{i}TYPE == OMNI // ----- omni light -----\n\n            #if LIGHT{i}SHADOWTYPE == PCSS_32F\n\n                #if LIGHT{i}SHAPE != PUNCTUAL\n                    vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;\n                #else\n                    vec2 shadowSearchArea = vec2(light{i}_shadowSearchArea);\n                #endif\n\n                return getShadowOmniPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);\n\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n                return getShadowOmniPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, lightDirW);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n                return getShadowOmniPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, lightDirW);\n            #endif\n\n        #endif\n    }\n#endif\n";
export default _default;
