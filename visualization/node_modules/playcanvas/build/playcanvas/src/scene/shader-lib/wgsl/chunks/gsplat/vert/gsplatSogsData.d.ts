declare const _default: "\nvar means_u: texture_2d<f32>;\nvar means_l: texture_2d<f32>;\nvar quats: texture_2d<f32>;\nvar scales: texture_2d<f32>;\n\nuniform means_mins: vec3f;\nuniform means_maxs: vec3f;\n\nuniform scales_mins: vec3f;\nuniform scales_maxs: vec3f;\n\n// read the model-space center of the gaussian\nfn readCenter(source: ptr<function, SplatSource>) -> vec3f {\n    let u: vec3f = textureLoad(means_u, source.uv, 0).xyz;\n    let l: vec3f = textureLoad(means_l, source.uv, 0).xyz;\n    let n: vec3f = (l * 255.0 + u * 255.0 * 256.0) / 65535.0;\n\n    let v: vec3f = mix(uniform.means_mins, uniform.means_maxs, n);\n    return sign(v) * (exp(abs(v)) - 1.0);\n}\n\nconst norm: f32 = 2.0 / sqrt(2.0);\n\n// sample covariance vectors\nfn readCovariance(source: ptr<function, SplatSource>, covA_ptr: ptr<function, vec3f>, covB_ptr: ptr<function, vec3f>) {\n    let qdata: vec4f = textureLoad(quats, source.uv, 0);\n    let abc: vec3f = (qdata.xyz - 0.5) * norm;\n    let d: f32 = sqrt(max(0.0, 1.0 - dot(abc, abc)));\n\n    let mode: u32 = u32(qdata.w * 255.0 + 0.5) - 252u;\n\n    var quat: vec4f;\n    if (mode == 0u) {\n        quat = vec4f(d, abc);\n    } else if (mode == 1u) {\n        quat = vec4f(abc.x, d, abc.y, abc.z);\n    } else if (mode == 2u) {\n        quat = vec4f(abc.x, abc.y, d, abc.z);\n    } else {\n        quat = vec4f(abc.x, abc.y, abc.z, d);\n    }\n\n\n    let rot: mat3x3f = quatToMat3(quat);\n    let scale: vec3f = exp(mix(uniform.scales_mins, uniform.scales_maxs, textureLoad(scales, source.uv, 0).xyz));\n\n    // M = S * R\n    let M: mat3x3f = transpose(mat3x3f(\n        scale.x * rot[0],\n        scale.y * rot[1],\n        scale.z * rot[2]\n    ));\n\n    *covA_ptr = vec3f(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n    *covB_ptr = vec3f(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n";
export default _default;
