declare const _default: "\n\n#if LIGHT_TYPE != DIRECTIONAL\n    uniform view_position: vec3f;\n    uniform light_radius: f32;\n#endif\n\n#if SHADOW_TYPE == PCSS_32F\n    #include \"linearizeDepthPS\"\n#endif\n\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n\n    #include \"litUserMainStartPS\"\n\n    var output: FragmentOutput;\n\n    evaluateFrontend();\n\n    // using non-standard depth, i.e gl_FragCoord.z\n    #ifdef PERSPECTIVE_DEPTH\n        var depth: f32 = input.position.z;\n\n        #if SHADOW_TYPE == PCSS_32F\n            // spot/omni shadows currently use linear depth.\n            // TODO: use perspective depth for spot/omni the same way as directional\n            #if LIGHT_TYPE != DIRECTIONAL\n                depth = linearizeDepthWithParams(depth, camera_params);\n            #endif\n        #endif\n\n    #else\n        var depth: f32 = min(distance(uniform.view_position, input.vPositionW) / uniform.light_radius, 0.99999);\n        #define MODIFIED_DEPTH\n    #endif\n\n    #if SHADOW_TYPE == VSM_16F || SHADOW_TYPE == VSM_32F\n        #if SHADOW_TYPE == VSM_32F\n            var exponent: f32 = 15.0;\n        #else\n            var exponent: f32 = 5.54;\n        #endif\n\n        var depth_vsm = 2.0 * depth - 1.0;\n        depth_vsm = exp(exponent * depth_vsm);\n        output.color = vec4f(depth_vsm, depth_vsm * depth_vsm, 1.0, 1.0);\n    #else\n        #if SHADOW_TYPE == PCSS_32F\n            output.color = vec4f(depth, 0.0, 0.0, 1.0);\n        #else\n            #ifdef MODIFIED_DEPTH\n                // If we end up using modified depth, it needs to be explicitly written to gl_FragDepth\n                output.fragDepth = depth;\n            #endif\n\n            // just the simplest code, color is not written anyway\n            output.color = vec4f(1.0);\n        #endif\n    #endif\n\n    #include \"litUserMainEndPS\"\n    \n    return output;\n}\n";
export default _default;
