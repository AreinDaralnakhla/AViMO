declare const _default: "\n#if defined(LIGHT{i})\n\nfn evaluateLight{i}(\n    #if defined(LIT_IRIDESCENCE)\n        iridescenceFresnel: vec3f\n    #endif\n) {\n    // light color\n    var lightColor: vec3f = uniform.light{i}_color;\n\n    #if LIGHT{i}TYPE == DIRECTIONAL && !defined(LIT_SHADOW_CATCHER)\n        // early return if the light color is black (used by shadow catcher - this way this light is very cheap)\n        if (all(lightColor == vec3f(0.0, 0.0, 0.0))) {\n            return;\n        }\n    #endif\n\n    #if LIGHT{i}TYPE == DIRECTIONAL // directional light\n\n        dLightDirNormW = uniform.light{i}_direction;\n        dAtten = 1.0;\n\n    #else // omni or spot light\n\n        var lightDirW: vec3f = evalOmniLight(uniform.light{i}_position);\n        dLightDirNormW = normalize(lightDirW);\n\n        // cookie attenuation\n        #if defined(LIGHT{i}COOKIE)\n\n            #if LIGHT{i}TYPE == SPOT\n                #ifdef LIGHT{i}COOKIE_FALLOFF\n                    #ifdef LIGHT{i}COOKIE_TRANSFORM\n                        var cookieAttenuation: vec3f = getCookie2DXform(uniform.light{i}_cookie, uniform.light{i}_shadowMatrix, uniform.light{i}_cookieIntensity, uniform.light{i}_cookieMatrix, uniform.light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};\n                    #else\n                        var cookieAttenuation: vec3f = getCookie2D(uniform.light{i}_cookie, uniform.light{i}_shadowMatrix, uniform.light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n                    #endif\n                #else\n                    #ifdef LIGHT{i}COOKIE_TRANSFORM\n                        var cookieAttenuation: vec3f = getCookie2DClipXform(uniform.light{i}_cookie, uniform.light{i}_shadowMatrix, uniform.light{i}_cookieIntensity, uniform.light{i}_cookieMatrix, uniform.light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};\n                    #else\n                        var cookieAttenuation: vec3f = getCookie2DClip(uniform.light{i}_cookie, uniform.light{i}_shadowMatrix, uniform.light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n                    #endif\n                #endif\n            #endif\n\n            #if LIGHT{i}TYPE == OMNI\n                var cookieAttenuation: vec3f = getCookieCube(uniform.light{i}_cookie, uniform.light{i}_shadowMatrix, uniform.light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n            #endif\n\n            // multiply light color by the cookie attenuation\n            lightColor = lightColor * cookieAttenuation;\n\n        #endif\n\n        // distance falloff\n        #if LIGHT{i}SHAPE == PUNCTUAL\n            #if LIGHT{i}FALLOFF == LINEAR\n                dAtten = getFalloffLinear(uniform.light{i}_radius, lightDirW);\n            #else\n                dAtten = getFalloffInvSquared(uniform.light{i}_radius, lightDirW);\n            #endif\n        #else\n            // non punctual lights only gets the range window here\n            dAtten = getFalloffWindow(uniform.light{i}_radius, lightDirW);\n        #endif\n\n        // spot light angle falloff\n        #if LIGHT{i}TYPE == SPOT\n            #if !defined(LIGHT{i}COOKIE) || defined(LIGHT{i}COOKIE_FALLOFF)\n                dAtten = dAtten * getSpotEffect(uniform.light{i}_direction, uniform.light{i}_innerConeAngle, uniform.light{i}_outerConeAngle, dLightDirNormW);\n            #endif\n        #endif\n    #endif\n\n    if (dAtten < 0.00001) {\n        return;\n    }\n\n    // evaluate area light values\n    #if LIGHT{i}SHAPE != PUNCTUAL\n        #if LIGHT{i}SHAPE == RECT\n            calcRectLightValues(uniform.light{i}_position, uniform.light{i}_halfWidth, uniform.light{i}_halfHeight);\n        #elif LIGHT{i}SHAPE == DISK\n            calcDiskLightValues(uniform.light{i}_position, uniform.light{i}_halfWidth, uniform.light{i}_halfHeight);\n        #elif LIGHT{i}SHAPE == SPHERE\n            calcSphereLightValues(uniform.light{i}_position, uniform.light{i}_halfWidth, uniform.light{i}_halfHeight);\n        #endif\n    #endif\n\n    // diffuse lighting - LTC lights do not mix diffuse lighting into attenuation that affects specular\n    #if LIGHT{i}SHAPE != PUNCTUAL\n\n        // attenDiffuse - separate diffuse attenuation for non-punctual light sources\n\n        #if LIGHT{i}TYPE == DIRECTIONAL\n            // NB: A better approximation perhaps using wrap lighting could be implemented here\n            var attenDiffuse: f32 = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirNormW);\n        #else\n            // 16.0 is a constant that is in getFalloffInvSquared()\n            #if LIGHT{i}SHAPE == RECT\n                var attenDiffuse: f32 = getRectLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n            #elif LIGHT{i}SHAPE == DISK\n                var attenDiffuse: f32 = getDiskLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n            #elif LIGHT{i}SHAPE == SPHERE\n                var attenDiffuse: f32 = getSphereLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n            #endif\n        #endif\n    #else\n        // one parameter is unused for punctual lights\n        dAtten = dAtten * getLightDiffuse(litArgs_worldNormal, vec3(0.0), dLightDirNormW);\n    #endif\n\n    // apply the shadow attenuation\n    #ifdef LIGHT{i}CASTSHADOW\n\n        #if LIGHT{i}TYPE == DIRECTIONAL\n            var shadow: f32 = getShadow{i}(vec3(0.0));\n        #else\n            var shadow: f32 = getShadow{i}(lightDirW);\n        #endif\n\n        // Apply shadow intensity to the shadow value\n        shadow = mix(1.0, shadow, uniform.light{i}_shadowIntensity);\n\n        dAtten = dAtten * shadow;\n\n        #if defined(LIT_SHADOW_CATCHER) && LIGHT{i}TYPE == DIRECTIONAL\n            // accumulate shadows for directional lights\n            dShadowCatcher = dShadowCatcher * shadow;\n        #endif            \n\n    #endif\n\n    #if LIGHT{i}SHAPE != PUNCTUAL\n        // area light - they do not mix diffuse lighting into specular attenuation\n        #ifdef LIT_SPECULAR\n            dDiffuseLight = dDiffuseLight + (((attenDiffuse * dAtten) * lightColor) * (1.0 - dLTCSpecFres));\n        #else\n            dDiffuseLight = dDiffuseLight + ((attenDiffuse * dAtten) * lightColor);\n        #endif                        \n    #else\n        // punctual light\n        #if defined(AREA_LIGHTS) && defined(LIT_SPECULAR)\n            dDiffuseLight = dDiffuseLight + ((dAtten * lightColor) * (1.0 - litArgs_specularity));\n        #else\n            dDiffuseLight = dDiffuseLight + (dAtten * lightColor);\n        #endif\n    #endif\n\n    // specular lighting\n    #ifdef LIGHT{i}AFFECT_SPECULARITY\n\n        #if LIGHT{i}SHAPE != PUNCTUAL // area light\n\n            #ifdef LIT_CLEARCOAT\n                #if LIGHT{i}SHAPE == RECT\n                    ccSpecularLight = ccSpecularLight + (ccLTCSpecFres * getRectLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor);\n                #elif LIGHT{i}SHAPE == DISK\n                    ccSpecularLight = ccSpecularLight + (ccLTCSpecFres * getDiskLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor);\n                #elif LIGHT{i}SHAPE == SPHERE\n                    ccSpecularLight = ccSpecularLight + (ccLTCSpecFres * getSphereLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor);\n                #endif\n            #endif\n\n            #ifdef LIT_SPECULAR\n                #if LIGHT{i}SHAPE == RECT\n                    dSpecularLight = dSpecularLight + (dLTCSpecFres * getRectLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor);\n                #elif LIGHT{i}SHAPE == DISK\n                    dSpecularLight = dSpecularLight + (dLTCSpecFres * getDiskLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor);\n                #elif LIGHT{i}SHAPE == SPHERE\n                    dSpecularLight = dSpecularLight + (dLTCSpecFres * getSphereLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor);\n                #endif\n            #endif\n\n        #else // punctual light\n\n            // is fresnel needed\n            #if LIGHT{i}TYPE == DIRECTIONAL && LIT_FRESNEL_MODEL != NONE\n                #define LIGHT{i}FRESNEL\n            #endif\n\n            #ifdef LIT_SPECULAR\n                var halfDirW: vec3f = normalize(-dLightDirNormW + dViewDirW);\n            #endif\n\n            // if LTC lights are present, specular must be accumulated with specularity (specularity is pre multiplied by punctual light fresnel)\n            #ifdef LIT_CLEARCOAT\n                var lightspecularCC: vec3f = getLightSpecular(halfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * lightColor;\n                #ifdef LIGHT{i}FRESNEL\n                    lightspecularCC = lightspecularCC * getFresnelCC(dot(dViewDirW, halfDirW));\n                #endif\n                ccSpecularLight = ccSpecularLight + lightspecularCC;\n            #endif\n\n            #ifdef LIT_SHEEN\n                sSpecularLight = sSpecularLight + (getLightSpecularSheen(halfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * lightColor);\n            #endif\n\n            #ifdef LIT_SPECULAR\n\n                var lightSpecular: vec3f = getLightSpecular(halfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * lightColor;\n                #ifdef LIGHT{i}FRESNEL\n\n                    #if defined(LIT_IRIDESCENCE)\n                        lightSpecular = lightSpecular * getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity, iridescenceFresnel, litArgs_iridescence_intensity);\n                    #else\n                        lightSpecular = lightSpecular * getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity);\n                    #endif\n\n                #else\n                    lightSpecular = lightSpecular * litArgs_specularity;\n                #endif\n                \n                dSpecularLight = dSpecularLight + lightSpecular;\n            #endif\n        #endif\n    #endif\n}\n#endif\n";
export default _default;
