declare const _default: "\n\n// stores the source UV and order of the splat\nstruct SplatSource {\n    order: u32,         // render order\n    id: u32,            // splat id\n    uv: vec2<i32>,      // splat uv\n    cornerUV: vec2f,    // corner coordinates for this vertex of the gaussian (-1, -1)..(1, 1)\n}\n\n// stores the camera and clip space position of the gaussian center\nstruct SplatCenter {\n    view: vec3f,          // center in view space\n    proj: vec4f,          // center in clip space\n    modelView: mat4x4f,   // model-view matrix\n    projMat00: f32,       // elememt [0][0] of the projection matrix\n}\n\n// stores the offset from center for the current gaussian\nstruct SplatCorner {\n    offset: vec2f,        // corner offset from center in clip space\n    uv: vec2f,            // corner uv\n    #if GSPLAT_AA\n        aaFactor: f32, // for scenes generated with antialiasing\n    #endif\n}\n\nfn quatToMat3(R: vec4<f32>) -> mat3x3<f32> {\n    let R2: vec4<f32> = R + R;\n    let X: f32       = R2.x * R.w;\n    let Y: vec4<f32> = R2.y * R;\n    let Z: vec4<f32> = R2.z * R;\n    let W: f32       = R2.w * R.w;\n\n    return mat3x3<f32>(\n        1.0 - Z.z - W,  Y.z + X,      Y.w - Z.x,\n        Y.z - X,        1.0 - Y.y - W, Z.w + Y.x,\n        Y.w + Z.x,      Z.w - Y.x,     1.0 - Y.y - Z.z\n    );\n}\n\n#if SH_BANDS == 1\n    const SH_COEFFS: i32 = 3;\n#elif SH_BANDS == 2\n    const SH_COEFFS: i32 = 8;\n#elif SH_BANDS == 3\n    const SH_COEFFS: i32 = 15;\n#else\n    const SH_COEFFS: i32 = 0;\n#endif\n\n#if GSPLAT_COMPRESSED_DATA\n    #include \"gsplatCompressedDataVS\"\n    #if SH_BANDS > 0\n        #include \"gsplatCompressedSHVS\"\n    #endif\n#elif GSPLAT_SOGS_DATA\n    #include \"gsplatSogsDataVS\"\n    #include \"gsplatSogsColorVS\"\n    #if SH_BANDS > 0\n        #include \"gsplatSogsSHVS\"\n    #endif\n#else\n    #include \"gsplatDataVS\"\n    #include \"gsplatColorVS\"\n    #if SH_BANDS > 0\n        #include \"gsplatSHVS\"\n    #endif\n#endif\n\n#include \"gsplatSourceVS\"\n#include \"gsplatCenterVS\"\n#include \"gsplatCornerVS\"\n#include \"gsplatOutputVS\"\n\n// modify the gaussian corner so it excludes gaussian regions with alpha less than 1/255\nfn clipCorner(corner: ptr<function, SplatCorner>, alpha: f32) {\n    let clip: f32 = min(1.0, sqrt(-log(1.0 / (255.0 * alpha))) / 2.0);\n    corner.offset = corner.offset * clip;\n    corner.uv = corner.uv * clip;\n}\n\n// spherical Harmonics\n\n#if SH_BANDS > 0\n    const SH_C1: f32 = 0.4886025119029199;\n\n    #if SH_BANDS > 1\n        const SH_C2_0: f32 = 1.0925484305920792;\n        const SH_C2_1: f32 = -1.0925484305920792;\n        const SH_C2_2: f32 = 0.31539156525252005;\n        const SH_C2_3: f32 = -1.0925484305920792;\n        const SH_C2_4: f32 = 0.5462742152960396;\n    #endif\n\n    #if SH_BANDS > 2\n        const SH_C3_0: f32 = -0.5900435899266435;\n        const SH_C3_1: f32 = 2.890611442640554;\n        const SH_C3_2: f32 = -0.4570457994644658;\n        const SH_C3_3: f32 = 0.3731763325901154;\n        const SH_C3_4: f32 = -0.4570457994644658;\n        const SH_C3_5: f32 = 1.445305721320277;\n        const SH_C3_6: f32 = -0.5900435899266435;\n    #endif\n\n    // see https://github.com/graphdeco-inria/gaussian-splatting/blob/main/utils/sh_utils.py\n    fn evalSH(source: ptr<function, SplatSource>, dir: vec3f) -> vec3f {\n\n        var sh: array<vec3f, SH_COEFFS>;\n\n        var scale: f32;\n        readSHData(source, &sh, &scale);\n\n        let x = dir.x;\n        let y = dir.y;\n        let z = dir.z;\n\n        // 1st degree\n        var result = SH_C1 * (-sh[0] * y + sh[1] * z - sh[2] * x);\n\n        #if SH_BANDS > 1\n            // 2nd degree\n            let xx = x * x;\n            let yy = y * y;\n            let zz = z * z;\n            let xy = x * y;\n            let yz = y * z;\n            let xz = x * z;\n\n            result = result + (\n                sh[3] * (SH_C2_0 * xy) +\n                sh[4] * (SH_C2_1 * yz) +\n                sh[5] * (SH_C2_2 * (2.0 * zz - xx - yy)) +\n                sh[6] * (SH_C2_3 * xz) +\n                sh[7] * (SH_C2_4 * (xx - yy))\n            );\n        #endif\n\n        #if SH_BANDS > 2\n            // 3rd degree\n            result = result + (\n                sh[8]  * (SH_C3_0 * y * (3.0 * xx - yy)) +\n                sh[9]  * (SH_C3_1 * xy * z) +\n                sh[10] * (SH_C3_2 * y * (4.0 * zz - xx - yy)) +\n                sh[11] * (SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy)) +\n                sh[12] * (SH_C3_4 * x * (4.0 * zz - xx - yy)) +\n                sh[13] * (SH_C3_5 * z * (xx - yy)) +\n                sh[14] * (SH_C3_6 * x * (xx - 3.0 * yy))\n            );\n        #endif\n\n        return result * scale;\n    }\n#endif\n";
export default _default;
