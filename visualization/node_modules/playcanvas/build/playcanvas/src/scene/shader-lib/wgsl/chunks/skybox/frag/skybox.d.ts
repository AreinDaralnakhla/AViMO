declare const _default: "\n    #define LIT_SKYBOX_INTENSITY\n\n    #include \"envProcPS\"\n    #include \"gammaPS\"\n    #include \"tonemappingPS\"\n\n    #ifdef PREPASS_PASS\n        varying vLinearDepth: f32;\n        #include \"floatAsUintPS\"\n    #endif\n\n    // Varying and uniform declarations\n    varying vViewDir : vec3f;\n    uniform skyboxHighlightMultiplier : f32;\n\n    #ifdef SKY_CUBEMAP\n\n        var texture_cubeMap : texture_cube<f32>;\n        var texture_cubeMap_sampler : sampler;\n\n        #ifdef SKYMESH\n            varying vWorldPos : vec3f;\n            uniform cubeMapRotationMatrix : mat3x3f;\n            uniform projectedSkydomeCenter : vec3f;\n        #endif\n\n    #else // env-atlas\n\n        #include \"sphericalPS\"\n        #include \"envAtlasPS\"\n\n        var texture_envAtlas : texture_2d<f32>;\n        var texture_envAtlas_sampler : sampler;\n\n        uniform mipLevel : f32;\n\n    #endif\n\n    @fragment\n    fn fragmentMain(input : FragmentInput) -> FragmentOutput {\n\n        var output: FragmentOutput;\n\n        #ifdef PREPASS_PASS\n\n            // output linear depth during prepass\n            output.color = float2vec4(vLinearDepth);\n\n        #else\n\n            var linear : vec3f;\n            var dir : vec3f;\n\n            #ifdef SKY_CUBEMAP\n\n                #ifdef SKYMESH\n                    // get vector from world space pos to tripod origin\n                    var envDir : vec3f = normalize(input.vWorldPos - uniform.projectedSkydomeCenter);\n                    dir = envDir * uniform.cubeMapRotationMatrix;\n                #else\n                    dir = input.vViewDir;\n                #endif\n\n                dir.x *= -1.0;\n                linear = {SKYBOX_DECODE_FNC}(textureSample(texture_cubeMap, texture_cubeMap_sampler, dir));\n\n            #else // env-atlas\n\n                dir = input.vViewDir * vec3f(-1.0, 1.0, 1.0);\n                let uv : vec2f = toSphericalUv(normalize(dir));\n                linear = {SKYBOX_DECODE_FNC}(textureSample(texture_envAtlas, texture_envAtlas_sampler, mapRoughnessUv(uv, uniform.mipLevel)));\n\n            #endif\n\n            // our HDR encodes values up to 64, so allow extra brightness for the clipped values\n            if (any(linear >= vec3f(64.0))) {\n                linear *= uniform.skyboxHighlightMultiplier;\n            }\n            \n            output.color = vec4f(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n\n        #endif\n\n        return output;\n    }\n";
export default _default;
