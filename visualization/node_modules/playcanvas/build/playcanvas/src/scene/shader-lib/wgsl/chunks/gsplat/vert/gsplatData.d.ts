declare const _default: "\nvar transformA: texture_2d<u32>;\nvar transformB: texture_2d<f32>;\n\n// work values\nvar<private> tAw: u32;\n\n// read the model-space center of the gaussian\nfn readCenter(source: ptr<function, SplatSource>) -> vec3f {\n    // read transform data\n    let tA: vec4<u32> = textureLoad(transformA, source.uv, 0);\n    tAw = tA.w;\n    return bitcast<vec3f>(tA.xyz);\n}\n\nfn unpackRotation(packed: vec3f) -> vec4f {\n    return vec4f(packed.xyz, sqrt(max(0.0, 1.0 - dot(packed, packed))));\n}\n\n// sample covariance vectors\nfn readCovariance(source: ptr<function, SplatSource>, covA_ptr: ptr<function, vec3f>, covB_ptr: ptr<function, vec3f>) {\n    let tB: vec4f = textureLoad(transformB, source.uv, 0);\n\n    let rot: mat3x3f = quatToMat3(unpackRotation(vec3f(unpack2x16float(bitcast<u32>(tAw)), tB.w)).wxyz);\n    let scale: vec3f = tB.xyz;\n\n    // M = S * R\n    let M = transpose(mat3x3f(\n        scale.x * rot[0],\n        scale.y * rot[1],\n        scale.z * rot[2]\n    ));\n\n    *covA_ptr = vec3f(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n    *covB_ptr = vec3f(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n";
export default _default;
