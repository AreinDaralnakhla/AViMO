declare const _default: "\nvar packedTexture: texture_2d<u32>;\nvar chunkTexture: texture_2d<f32>;\n\n// work values\nvar<private> chunkDataA: vec4f;    // x: min_x, y: min_y, z: min_z, w: max_x\nvar<private> chunkDataB: vec4f;    // x: max_y, y: max_z, z: scale_min_x, w: scale_min_y\nvar<private> chunkDataC: vec4f;    // x: scale_min_z, y: scale_max_x, z: scale_max_y, w: scale_max_z\nvar<private> chunkDataD: vec4f;    // x: min_r, y: min_g, z: min_b, w: max_r\nvar<private> chunkDataE: vec4f;    // x: max_g, y: max_b, z: unused, w: unused\nvar<private> packedData: vec4u;    // x: position bits, y: rotation bits, z: scale bits, w: color bits\n\nfn unpack111011(bits: u32) -> vec3f {\n    return (vec3f((vec3<u32>(bits) >> vec3<u32>(21u, 11u, 0u)) & vec3<u32>(0x7ffu, 0x3ffu, 0x7ffu))) / vec3f(2047.0, 1023.0, 2047.0);\n}\n\nfn unpack8888(bits: u32) -> vec4f {\n    return vec4f(\n        f32((bits >> 24u) & 0xffu),\n        f32((bits >> 16u) & 0xffu),\n        f32((bits >> 8u)  & 0xffu),\n        f32(bits         & 0xffu)\n    ) / 255.0;\n}\n\nconst norm_const: f32 = 1.0 / (sqrt(2.0) * 0.5);\n\nfn unpackRotation(bits: u32) -> vec4f {\n    let a = (f32((bits >> 20u) & 0x3ffu) / 1023.0 - 0.5) * norm_const;\n    let b = (f32((bits >> 10u) & 0x3ffu) / 1023.0 - 0.5) * norm_const;\n    let c = (f32(bits & 0x3ffu) / 1023.0 - 0.5) * norm_const;\n    let m = sqrt(1.0 - (a * a + b * b + c * c));\n\n    let mode = bits >> 30u;\n    if (mode == 0u) { return vec4f(m, a, b, c); }\n    if (mode == 1u) { return vec4f(a, m, b, c); }\n    if (mode == 2u) { return vec4f(a, b, m, c); }\n    return vec4f(a, b, c, m);\n}\n\n// read center\nfn readCenter(source: ptr<function, SplatSource>) -> vec3f {\n    let tex_size_u = textureDimensions(chunkTexture, 0);\n    let w: u32 = tex_size_u.x / 5u;\n    let chunkId: u32 = source.id / 256u;\n    let chunkUV: vec2<i32> = vec2<i32>(i32((chunkId % w) * 5u), i32(chunkId / w));\n\n    // read chunk and packed compressed data\n    chunkDataA = textureLoad(chunkTexture, chunkUV + vec2<i32>(0, 0), 0);\n    chunkDataB = textureLoad(chunkTexture, chunkUV + vec2<i32>(1, 0), 0);\n    chunkDataC = textureLoad(chunkTexture, chunkUV + vec2<i32>(2, 0), 0);\n    chunkDataD = textureLoad(chunkTexture, chunkUV + vec2<i32>(3, 0), 0);\n    chunkDataE = textureLoad(chunkTexture, chunkUV + vec2<i32>(4, 0), 0);\n    packedData = textureLoad(packedTexture, source.uv, 0);\n\n    return mix(chunkDataA.xyz, vec3f(chunkDataA.w, chunkDataB.xy), unpack111011(packedData.x));\n}\n\nfn readColor(source: ptr<function, SplatSource>) -> vec4f {\n    let r = unpack8888(packedData.w);\n    return vec4f(mix(chunkDataD.xyz, vec3f(chunkDataD.w, chunkDataE.xy), r.rgb), r.w);\n}\n\nfn getRotation() -> vec4f {\n    return unpackRotation(packedData.y);\n}\n\nfn getScale() -> vec3f {\n    return exp(mix(vec3f(chunkDataB.zw, chunkDataC.x), chunkDataC.yzw, unpack111011(packedData.z)));\n}\n\n// given a rotation matrix and scale vector, compute 3d covariance A and B\nfn readCovariance(source: ptr<function, SplatSource>, covA_ptr: ptr<function, vec3f>, covB_ptr: ptr<function, vec3f>) {\n    let rot = quatToMat3(getRotation());\n    let scale = getScale();\n\n    // M = S * R\n    let M = transpose(mat3x3f(\n        scale.x * rot[0],\n        scale.y * rot[1],\n        scale.z * rot[2]\n    ));\n\n    *covA_ptr = vec3f(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n    *covB_ptr = vec3f(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n";
export default _default;
