declare const _default: "\n// Anisotropic GGX\nfn calcLightSpecular(gloss: f32, worldNormal: vec3f, viewDir: vec3f, h: vec3f, lightDirNorm: vec3f, tbn: mat3x3f) -> f32 {\n    let PI: f32 = 3.141592653589793;\n    let roughness: f32 = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n    let alphaRoughness: f32 = roughness * roughness;\n    let anisotropy: f32 = dAnisotropy;\n    let direction: vec2f = dAnisotropyRotation;\n\n    let at: f32 = mix(alphaRoughness, 1.0, anisotropy * anisotropy);\n    let ab: f32 = clamp(alphaRoughness, 0.001, 1.0);\n\n    let anisotropicT: vec3f = normalize(tbn * vec3f(direction, 0.0));\n    let anisotropicB: vec3f = normalize(cross(tbn[2], anisotropicT));\n\n    let NoH: f32 = dot(worldNormal, h);\n    let ToH: f32 = dot(anisotropicT, h);\n    let BoH: f32 = dot(anisotropicB, h);\n\n    let a2: f32 = at * ab;\n    let v: vec3f = vec3f(ab * ToH, at * BoH, a2 * NoH);\n    let v2: f32 = dot(v, v);\n    let w2: f32 = a2 / v2;\n    let D: f32 = a2 * w2 * w2 * (1.0 / PI);\n\n    let ToV: f32 = dot(anisotropicT, viewDir);\n    let BoV: f32 = dot(anisotropicB, viewDir);\n    let ToL: f32 = dot(anisotropicT, -lightDirNorm);\n    let BoL: f32 = dot(anisotropicB, -lightDirNorm);\n    let NoV: f32 = dot(worldNormal, viewDir);\n    let NoL: f32 = dot(worldNormal, -lightDirNorm);\n\n    let lambdaV: f32 = NoL * length(vec3f(at * ToV, ab * BoV, NoV));\n    let lambdaL: f32 = NoV * length(vec3f(at * ToL, ab * BoL, NoL));\n    let G: f32 = 0.5 / (lambdaV + lambdaL);\n\n    return D * G;\n}\n\nfn getLightSpecular(h: vec3f, reflDir: vec3f, worldNormal: vec3f, viewDir: vec3f, lightDirNorm: vec3f, gloss: f32, tbn: mat3x3f) -> f32 {\n    return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);\n}\n";
export default _default;
