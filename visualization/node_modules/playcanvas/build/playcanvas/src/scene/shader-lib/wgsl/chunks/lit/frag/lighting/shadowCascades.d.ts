declare const _default: "\n\n// function which selects a shadow projection matrix index based on cascade distances\nfn getShadowCascadeIndex(shadowCascadeDistances: vec4f, shadowCascadeCount: i32) -> i32 {\n\n    // depth in 0 .. far plane range\n    let depth: f32 = 1.0 / pcPosition.w;\n\n    // 1.0 if depth >= distance, 0.0 otherwise\n    let comparisons: vec4f = step(shadowCascadeDistances, vec4f(depth));\n\n    // sum is the index\n    let cascadeIndex: i32 = i32(dot(comparisons, vec4f(1.0)));\n\n    // limit to actual number of used cascades\n    return min(cascadeIndex, shadowCascadeCount - 1);\n}\n\n// function which modifies cascade index to dither between cascades\nfn ditherShadowCascadeIndex(cascadeIndex_in: i32, shadowCascadeDistances: vec4f, shadowCascadeCount: i32, blendFactor: f32) -> i32 {\n\n    // Use var as cascadeIndex might be modified\n    var cascadeIndex: i32 = cascadeIndex_in;\n    if (cascadeIndex < shadowCascadeCount - 1) {\n        let currentRangeEnd: f32 = shadowCascadeDistances[cascadeIndex];\n        let transitionStart: f32 = blendFactor * currentRangeEnd; // Start overlap factor away from the end distance\n        let depth: f32 = 1.0 / pcPosition.w;\n\n        if (depth > transitionStart) {\n            // Calculate a transition factor (0.0 to 1.0) within the overlap range\n            let transitionFactor: f32 = smoothstep(transitionStart, currentRangeEnd, depth);\n\n            // Add pseudo-random dithering\n            // TODO: replace by user selectable dithering method\n            let dither: f32 = fract(sin(dot(pcPosition.xy, vec2f(12.9898, 78.233))) * 43758.5453);\n            if (dither < transitionFactor) {\n                cascadeIndex = cascadeIndex + 1;\n            }\n        }\n    }\n\n    return cascadeIndex;\n}\n\nfn fadeShadow(shadowCoord_in: vec3f, shadowCascadeDistances: vec4f) -> vec3f {\n    // if the pixel is past the shadow distance, remove shadow\n    // this enforces straight line instead of corner of shadow which moves when camera rotates\n    var shadowCoord: vec3f = shadowCoord_in;\n    let depth: f32 = 1.0 / pcPosition.w;\n    if (depth > shadowCascadeDistances.w) {\n        shadowCoord.z = -9999999.0;\n    }\n\n    return shadowCoord;\n}\n";
export default _default;
