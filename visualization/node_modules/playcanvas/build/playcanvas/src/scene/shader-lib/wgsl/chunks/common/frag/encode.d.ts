declare const _default: "\nfn encodeLinear(source: vec3f) -> vec4f {\n    return vec4f(source, 1.0);\n}\n\nfn encodeGamma(source: vec3f) -> vec4f {\n    return vec4f(pow(source + vec3f(0.0000001), vec3f(1.0 / 2.2)), 1.0);\n}\n\nfn encodeRGBM(source: vec3f) -> vec4f {\n    var color: vec3f = pow(source, vec3f(0.5));\n    color *= 1.0 / 8.0;\n\n    var a: f32 = saturate(max(max(color.r, color.g), max(color.b, 1.0 / 255.0)));\n    a = ceil(a * 255.0) / 255.0;\n\n    color /= a;\n    return vec4f(color, a);\n}\n\nfn encodeRGBP(source: vec3f) -> vec4f {\n    // convert incoming linear to gamma(ish)\n    var gamma: vec3f = pow(source, vec3f(0.5));\n\n    // calculate the maximum component clamped to 1..8\n    var maxVal: f32 = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));\n\n    // calculate storage factor\n    var v: f32 = 1.0 - ((maxVal - 1.0) / 7.0);\n\n    // round the value for storage in 8bit channel\n    v = ceil(v * 255.0) / 255.0;\n\n    return vec4f(gamma / (-v * 7.0 + 8.0), v);\n}\n\nfn encodeRGBE(source: vec3f) -> vec4f {\n    var maxVal: f32 = max(source.x, max(source.y, source.z));\n    if (maxVal < 1e-32) {\n        return vec4f(0.0, 0.0, 0.0, 0.0);\n    } else {\n        var e: f32 = ceil(log2(maxVal));\n        return vec4f(source / pow(2.0, e), (e + 128.0) / 255.0);\n    }\n}\n";
export default _default;
