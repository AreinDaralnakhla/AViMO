declare const _default: "\nattribute vec4 aPosition;\n\nuniform mat4 matrix_view;\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\n\nvarying vec3 vViewDir;\n\n#ifdef PREPASS_PASS\n    // when skydome renders depth during prepass, generate linear depth\n    varying float vLinearDepth;\n#endif\n\n#ifdef SKYMESH\n    uniform mat4 matrix_model;\n    varying vec3 vWorldPos;\n#endif\n\nvoid main(void) {\n\n    mat4 view = matrix_view;\n\n    #ifdef SKYMESH\n\n        vec4 worldPos = matrix_model * aPosition;\n        vWorldPos = worldPos.xyz;\n        gl_Position = matrix_projectionSkybox * (view * worldPos);\n\n        #ifdef PREPASS_PASS\n            // linear depth from the worldPosition, see getLinearDepth\n            vLinearDepth = -(matrix_view * vec4(vWorldPos, 1.0)).z;\n        #endif\n\n    #else\n\n        view[3][0] = view[3][1] = view[3][2] = 0.0;\n        gl_Position = matrix_projectionSkybox * (view * aPosition);\n        vViewDir = aPosition.xyz * cubeMapRotationMatrix;\n\n        #ifdef PREPASS_PASS\n            // for infinite skybox, use negative gl_Position.w to get positive linear depth\n            vLinearDepth = -gl_Position.w;\n        #endif\n    #endif\n\n    // Force skybox to far Z, regardless of the clip planes on the camera\n    // Subtract a tiny fudge factor to ensure floating point errors don't\n    // still push pixels beyond far Z. See:\n    // https://community.khronos.org/t/skybox-problem/61857\n\n    gl_Position.z = gl_Position.w - 1.0e-7;\n}\n";
export default _default;
