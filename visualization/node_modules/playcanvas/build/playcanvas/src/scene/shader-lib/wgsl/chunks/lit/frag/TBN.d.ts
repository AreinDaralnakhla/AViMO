declare const _default: "\n\n#ifdef LIT_TANGENTS\n    #define TBN_TANGENTS\n#else\n    #if defined(LIT_USE_NORMALS) || defined(LIT_USE_CLEARCOAT_NORMALS)\n        #define TBN_DERIVATIVES\n    #endif\n#endif\n\n#if defined(TBN_DERIVATIVES)\n    uniform tbnBasis: f32;\n#endif\n\nfn getTBN(tangent: vec3f, binormal: vec3f, normal: vec3f) {\n\n    #ifdef TBN_TANGENTS // tangents / binormals based TBN\n\n        dTBN = mat3x3f(normalize(tangent), normalize(binormal), normalize(normal));\n\n    #elif defined(TBN_DERIVATIVES) // derivatives based TBN\n\n        let uv: vec2f = {lightingUv};\n\n        // get edge vectors of the pixel triangle\n        let dp1: vec3f = dpdx( vPositionW );\n        let dp2: vec3f = dpdy( vPositionW );\n        let duv1: vec2f = dpdx( uv );\n        let duv2: vec2f = dpdy( uv );\n\n        // solve the linear system\n        let dp2perp: vec3f = cross( dp2, normal );\n        let dp1perp: vec3f = cross( normal, dp1 );\n        let T: vec3f = dp2perp * duv1.x + dp1perp * duv2.x;\n        let B: vec3f = dp2perp * duv1.y + dp1perp * duv2.y;\n\n        // construct a scale-invariant frame\n        let denom: f32 = max( dot(T, T), dot(B, B) );\n        let invmax: f32 = select(uniform.tbnBasis / sqrt( denom ), 0.0, denom == 0.0);\n        dTBN = mat3x3f(T * invmax, -B * invmax, normal );\n\n    #else // object space TBN\n\n        var B: vec3f = cross(normal, vObjectSpaceUpW);\n        var T: vec3f = cross(normal, B);\n\n        if (dot(B,B) == 0.0) // deal with case when vObjectSpaceUpW normal are parallel\n        {\n            let major: f32 = max(max(normal.x, normal.y), normal.z);\n\n            if (normal.x == major)\n            {\n                B = cross(normal, vec3f(0.0, 1.0, 0.0));\n                T = cross(normal, B);\n            }\n            else if (normal.y == major)\n            {\n                B = cross(normal, vec3f(0.0, 0.0, 1.0));\n                T = cross(normal, B);\n            }\n            else // removed \"if (normal.z == major)\" assuming it's the only remaining case\n            {\n                B = cross(normal, vec3f(1.0, 0.0, 0.0));\n                T = cross(normal, B);\n            }\n        }\n\n        dTBN = mat3x3f(normalize(T), normalize(B), normalize(normal));\n\n    #endif\n}";
export default _default;
