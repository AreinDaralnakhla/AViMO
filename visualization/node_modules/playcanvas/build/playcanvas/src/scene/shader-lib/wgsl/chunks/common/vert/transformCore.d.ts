declare const _default: "\n\n    attribute vertex_position: vec4f;\n\n    uniform matrix_viewProjection: mat4x4f;\n    uniform matrix_model: mat4x4f;\n    \n    #ifdef MORPHING\n\n        uniform morph_tex_params: vec2f;\n        attribute morph_vertex_id: u32;\n\n        fn getTextureMorphCoords() -> vec2i {\n\n            // turn morph_vertex_id into int grid coordinates\n            var textureSize: vec2i = vec2i(uniform.morph_tex_params);\n            var morphGridV: i32 = i32(morph_vertex_id) / textureSize.x;\n            var morphGridU: i32 = i32(morph_vertex_id) - (morphGridV * textureSize.x);\n            morphGridV = textureSize.y - morphGridV - 1;\n            return vec2i(morphGridU, morphGridV);\n        }\n\n        #ifdef MORPHING_POSITION\n            #ifdef MORPHING_INT\n                uniform aabbSize: vec3f;\n                uniform aabbMin: vec3f;\n                var morphPositionTex: texture_2d<u32>;\n            #else\n                var morphPositionTex: texture_2d<f32>;\n            #endif\n        #endif\n    #endif\n\n    #ifdef defined(BATCH)\n        #include \"skinBatchVS\"\n\n        fn getModelMatrix() -> mat4x4f {\n            return getBoneMatrix(vertex_boneIndices);\n        }\n\n    #elif defined(SKIN)\n        #include \"skinVS\"\n        fn getModelMatrix() -> mat4x4f {\n            return uniform.matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n        }\n\n    #elif defined(INSTANCING)\n\n        #include \"transformInstancingVS\"\n\n    #else\n\n        fn getModelMatrix() -> mat4x4f {\n            return uniform.matrix_model;\n        }\n\n    #endif\n\n    fn getLocalPosition(vertexPosition: vec3f) -> vec3f {\n\n        var localPos: vec3f = vertexPosition;\n\n        #ifdef MORPHING_POSITION\n\n            var morphUV: vec2i = getTextureMorphCoords();\n\n            #ifdef MORPHING_INT\n                // Use textureLoad instead of texelFetch. Coordinates must be integer type (vec2i).\n                // WGSL requires explicit type conversion for vectors.\n                // Division by float literal ensures floating point division.\n                var morphPos: vec3f = vec3f(textureLoad(morphPositionTex, morphUV, 0).xyz) / 65535.0 * uniform.aabbSize + uniform.aabbMin;\n            #else\n                // Use textureLoad instead of texelFetch. Coordinates must be integer type (vec2i).\n                var morphPos: vec3f = textureLoad(morphPositionTex, morphUV, 0).xyz;\n            #endif\n\n            localPos += morphPos;\n\n        #endif\n\n        return localPos;\n    }\n";
export default _default;
