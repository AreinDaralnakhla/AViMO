declare const _default: "\n\n// shadow casting functionality\n#ifdef LIGHT{i}CASTSHADOW\n\n    // generate shadow coordinates function, based on per light defines:\n    // - _SHADOW_SAMPLE_NORMAL_OFFSET\n    // - _SHADOW_SAMPLE_ORTHO\n    // - _SHADOW_SAMPLE_POINT\n    // - _SHADOW_SAMPLE_SOURCE_ZBUFFER\n    fn getShadowSampleCoord{i}(shadowTransform: mat4x4f, shadowParams: vec4f, worldPosition: vec3f, lightPos: vec3f, lightDir: ptr<function, vec3f>, lightDirNorm: vec3f, normal: vec3f) -> vec3f {\n\n        var surfacePosition = worldPosition;\n\n        #ifdef LIGHT{i}_SHADOW_SAMPLE_POINT\n            #ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n                let distScale: f32 = length(*lightDir);\n                surfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n                *lightDir = surfacePosition - lightPos;\n                return *lightDir;\n            #endif\n        #else\n            #ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER\n                #ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n                    surfacePosition = surfacePosition + normal * shadowParams.y;\n                #endif\n            #else\n                #ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n                    #ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO\n                        var distScale: f32 = 1.0;\n                    #else\n                        var distScale: f32 = abs(dot(vPositionW - lightPos, lightDirNorm));\n                    #endif\n                    surfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n                #endif\n            #endif\n\n            // Use var for modification\n            var positionInShadowSpace: vec4f = shadowTransform * vec4f(surfacePosition, 1.0);\n            #ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO\n                positionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;\n            #else\n                #ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER\n                    positionInShadowSpace.xyz = positionInShadowSpace.xyz / positionInShadowSpace.w;\n                #else\n                    positionInShadowSpace.xy = positionInShadowSpace.xy / positionInShadowSpace.w;\n                    positionInShadowSpace.z = length(*lightDir) * shadowParams.w;\n                #endif\n            #endif\n\n            // this is currently unused\n            #ifdef SHADOW_SAMPLE_Z_BIAS\n                // positionInShadowSpace.z += getShadowBias(shadowParams.x, shadowParams.z);\n            #endif\n\n            surfacePosition = positionInShadowSpace.xyz;\n        #endif\n\n        return surfacePosition;\n    }\n\n    // shadow evaluation function\n    fn getShadow{i}(lightDirW_in: vec3f) -> f32 {\n\n        // directional shadow cascades\n        #ifdef LIGHT{i}_SHADOW_CASCADES\n\n            // select shadow cascade matrix\n            var cascadeIndex: i32 = getShadowCascadeIndex(uniform.light{i}_shadowCascadeDistances, uniform.light{i}_shadowCascadeCount);\n\n            #ifdef LIGHT{i}_SHADOW_CASCADE_BLEND\n                cascadeIndex = ditherShadowCascadeIndex(cascadeIndex, uniform.light{i}_shadowCascadeDistances, uniform.light{i}_shadowCascadeCount, uniform.light{i}_shadowCascadeBlend);\n            #endif\n\n            var shadowMatrix: mat4x4f = uniform.light{i}_shadowMatrixPalette[cascadeIndex];\n\n        #else\n\n            var shadowMatrix: mat4x4f = uniform.light{i}_shadowMatrix;\n\n        #endif\n\n        var lightDirArg = lightDirW_in;\n\n        #if LIGHT{i}TYPE == DIRECTIONAL\n            // directional light does not have a position\n            var shadowCoord: vec3f = getShadowSampleCoord{i}(shadowMatrix, uniform.light{i}_shadowParams, vPositionW, vec3f(0.0), &lightDirArg, dLightDirNormW, dVertexNormalW);\n        #else\n             var shadowCoord: vec3f = getShadowSampleCoord{i}(shadowMatrix, uniform.light{i}_shadowParams, vPositionW, uniform.light{i}_position, &lightDirArg, dLightDirNormW, dVertexNormalW);\n        #endif\n\n\n        // Fade directional shadow at the far distance\n        #if LIGHT{i}TYPE == DIRECTIONAL\n            shadowCoord = fadeShadow(shadowCoord, uniform.light{i}_shadowCascadeDistances);\n        #endif\n\n        // ----- sample the shadow -----\n\n        #if LIGHT{i}TYPE == DIRECTIONAL // ----- directional light -----\n\n            #if LIGHT{i}SHADOWTYPE == VSM_16F\n                return getShadowVSM16(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, 5.54);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == VSM_32F\n                return getShadowVSM32(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, 15.0);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCSS_32F\n\n                #if LIGHT{i}SHAPE != PUNCTUAL\n                    let shadowSearchArea = vec2f(length(uniform.light{i}_halfWidth), length(uniform.light{i}_halfHeight)) * uniform.light{i}_shadowSearchArea;\n                    return getShadowPCSS(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, uniform.light{i}_cameraParams, shadowSearchArea, lightDirW_in);\n                #else\n                    return getShadowPCSS(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, uniform.light{i}_cameraParams, uniform.light{i}_softShadowParams, lightDirW_in);\n                #endif\n\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n                return getShadowPCF1x1(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n                return getShadowPCF3x3(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F\n                return getShadowPCF5x5(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);\n            #endif\n\n        #endif\n\n\n        #if LIGHT{i}TYPE == SPOT // ----- spot light -----\n\n            #if LIGHT{i}SHADOWTYPE == VSM_16F\n                return getShadowSpotVSM16(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, 5.54, lightDirW_in);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == VSM_32F\n                return getShadowSpotVSM32(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, 15.0, lightDirW_in);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCSS_32F\n\n                #if LIGHT{i}SHAPE != PUNCTUAL\n                    var shadowSearchArea: vec2f = vec2f(length(uniform.light{i}_halfWidth), length(uniform.light{i}_halfHeight)) * uniform.light{i}_shadowSearchArea;\n                #else\n                    var shadowSearchArea: vec2f = vec2f(uniform.light{i}_shadowSearchArea);\n                #endif\n                return getShadowSpotPCSS(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, uniform.light{i}_cameraParams, shadowSearchArea, lightDirW_in);\n\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n                return getShadowSpotPCF1x1(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n                return getShadowSpotPCF3x3(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F\n                return getShadowSpotPCF5x5(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams);\n            #endif\n\n        #endif\n\n\n        #if LIGHT{i}TYPE == OMNI // ----- omni light -----\n\n            #if LIGHT{i}SHADOWTYPE == PCSS_32F\n\n                 var shadowSearchArea: vec2f; // Use var because assigned in if/else\n                 #if LIGHT{i}SHAPE != PUNCTUAL\n                    var shadowSearchArea: vec2f = vec2f(length(uniform.light{i}_halfWidth), length(uniform.light{i}_halfHeight)) * uniform.light{i}_shadowSearchArea;\n                #else\n                    var shadowSearchArea: vec2f = vec2f(uniform.light{i}_shadowSearchArea);\n                #endif\n\n                return getShadowOmniPCSS(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, uniform.light{i}_cameraParams, shadowSearchArea, lightDirW_in);\n\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n                return getShadowOmniPCF1x1(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, lightDirW_in);\n            #endif\n\n            #if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n                return getShadowOmniPCF3x3(light{i}_shadowMap, light{i}_shadowMapSampler, shadowCoord, uniform.light{i}_shadowParams, lightDirW_in);\n            #endif\n\n        #endif\n    }\n\n#endif\n";
export default _default;
