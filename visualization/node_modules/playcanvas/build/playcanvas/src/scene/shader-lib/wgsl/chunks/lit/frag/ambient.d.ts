declare const _default: "\n\n#if LIT_AMBIENT_SOURCE == AMBIENTSH\n    uniform ambientSH: array<vec3f, 9>;\n#endif\n\n#if LIT_AMBIENT_SOURCE == ENVALATLAS\n    #include \"envAtlasPS\"\n\n    #ifndef ENV_ATLAS\n        #define ENV_ATLAS\n        var texture_envAtlas: texture_2d<f32>;\n        var texture_envAtlasSampler: sampler;\n    #endif\n#endif\n\nfn addAmbient(worldNormal: vec3f) {\n    #ifdef LIT_AMBIENT_SOURCE == AMBIENTSH\n\n        let n: vec3f = cubeMapRotate(worldNormal);\n        let color: vec3f =\n            uniform.ambientSH[0] +\n            uniform.ambientSH[1] * n.x +\n            uniform.ambientSH[2] * n.y +\n            uniform.ambientSH[3] * n.z +\n            uniform.ambientSH[4] * n.x * n.z +\n            uniform.ambientSH[5] * n.z * n.y +\n            uniform.ambientSH[6] * n.y * n.x +\n            uniform.ambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n            uniform.ambientSH[8] * (n.x * n.x - n.y * n.y);\n\n        dDiffuseLight += processEnvironment(max(color, vec3f(0.0)));\n\n    #endif\n\n    #if LIT_AMBIENT_SOURCE == ENVALATLAS\n\n        let dir: vec3f = normalize(cubeMapRotate(worldNormal) * vec3f(-1.0, 1.0, 1.0));\n        let uv: vec2f = mapUv(toSphericalUv(dir), vec4f(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\n        let raw: vec4f = textureSample(texture_envAtlas, texture_envAtlasSampler, uv);\n        let linear: vec3f = {ambientDecode}(raw);\n        dDiffuseLight += processEnvironment(linear);\n\n    #endif\n\n    #if LIT_AMBIENT_SOURCE == CONSTANT\n\n        dDiffuseLight += uniform.light_globalAmbient;\n\n    #endif\n}\n";
export default _default;
