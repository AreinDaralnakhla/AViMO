declare const _default: "\nuniform outBoundsMul: vec3f;\nuniform outBoundsAdd: vec3f;\n\nfn encodeFloatRG( v: f32 ) -> vec2f {\n    var enc: vec2f = vec2f(1.0, 255.0) * v;\n    enc = fract(enc);\n    enc = enc - enc.yy * (1.0 / 255.0);\n    return enc;\n}\n\nfn encodeFloatRGBA( v: f32 ) -> vec4f {\n    let factors = vec4f(1.0, 255.0, 65025.0, 160581375.0);\n    var enc: vec4f = factors * v;\n    enc = fract(enc);\n    enc = enc - enc.yzww * vec4f(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n    return enc;\n}\n\nfn getOutput() -> vec4f {\n    outPos = outPos * uniform.outBoundsMul + uniform.outBoundsAdd;\n    outAngle = fract(outAngle / PI2);\n\n    outVel = (outVel / uniform.maxVel) + vec3f(0.5); // TODO: mul\n\n    let maxNegLife = max(uniform.lifetime, (uniform.numParticles - 1.0) * (uniform.rate + uniform.rateDiv));\n    let maxPosLife = uniform.lifetime + 1.0;\n    outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\n    if (pcPosition.y < 1.0) {\n        return vec4f(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n    } else if (pcPosition.y < 2.0) {\n        return vec4f(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n    } else if (pcPosition.y < 3.0) {\n        return vec4f(outVel, visMode * 0.5 + 0.5);\n    } else {\n        return encodeFloatRGBA(outLife);\n    }\n}\n";
export default _default;
