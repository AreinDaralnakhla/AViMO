declare const _default: "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\n    var texture_envAtlas: texture_2d<f32>;\n    var texture_envAtlasSampler: sampler;\n#endif\nuniform material_reflectivity: f32;\n\n// calculate mip level for shiny reflection given equirect coords uv.\nfn shinyMipLevel(uv: vec2f) -> f32 {\n    let dx: vec2f = dpdx(uv);\n    let dy: vec2f = dpdy(uv);\n\n    // calculate second dF at 180 degrees\n    let uv2: vec2f = vec2f(fract(uv.x + 0.5), uv.y);\n    let dx2: vec2f = dpdx(uv2);\n    let dy2: vec2f = dpdy(uv2);\n\n    // calculate min of both sets of dF to handle discontinuity at the azim edge\n    let maxd: f32 = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n\n    return clamp(0.5 * log2(maxd) - 1.0 + uniform.textureBias, 0.0, 5.0);\n}\n\nfn calcReflection(reflDir: vec3f, gloss: f32) -> vec3f {\n    let dir: vec3f = cubeMapProject(reflDir) * vec3f(-1.0, 1.0, 1.0);\n    let uv: vec2f = toSphericalUv(dir);\n\n    // calculate roughness level\n    let level: f32 = saturate(1.0 - gloss) * 5.0;\n    let ilevel: f32 = floor(level);\n\n    // accessing the shiny (top level) reflection - perform manual mipmap lookup\n    let level2: f32 = shinyMipLevel(uv * atlasSize);\n    let ilevel2: f32 = floor(level2);\n\n    var uv0: vec2f;\n    var uv1: vec2f;\n    var weight: f32;\n    if (ilevel == 0.0) {\n        uv0 = mapShinyUv(uv, ilevel2);\n        uv1 = mapShinyUv(uv, ilevel2 + 1.0);\n        weight = level2 - ilevel2;\n    } else {\n        // accessing rough reflection - just sample the same part twice\n        uv0 = mapRoughnessUv(uv, ilevel);\n        uv1 = uv0;\n        weight = 0.0;\n    }\n\n    let linearA: vec3f = {reflectionDecode}(textureSample(texture_envAtlas, texture_envAtlasSampler, uv0));\n    let linearB: vec3f = {reflectionDecode}(textureSample(texture_envAtlas, texture_envAtlasSampler, uv1));\n    let linear0: vec3f = mix(linearA, linearB, weight);\n    let linear1: vec3f = {reflectionDecode}(textureSample(texture_envAtlas, texture_envAtlasSampler, mapRoughnessUv(uv, ilevel + 1.0)));\n\n    return processEnvironment(mix(linear0, linear1, level - ilevel));\n}\n\nfn addReflection(reflDir: vec3f, gloss: f32) {\n    dReflection = dReflection + vec4f(calcReflection(reflDir, gloss), uniform.material_reflectivity);\n}\n";
export default _default;
