declare const _default: "\n#if defined(LIGHT{i})\n\nvoid evaluateLight{i}(\n    #if defined(LIT_IRIDESCENCE)\n        vec3 iridescenceFresnel\n    #endif\n) {\n\n    // light color\n    vec3 lightColor = light{i}_color;\n\n    #if LIGHT{i}TYPE == DIRECTIONAL && !defined(LIT_SHADOW_CATCHER)\n        // early return if the light color is black (used by shadow catcher - this way this light is very cheap)\n        if (all(equal(lightColor, vec3(0.0)))) {\n            return;\n        }\n    #endif\n\n    #if LIGHT{i}TYPE == DIRECTIONAL // directional light\n\n        dLightDirNormW = light{i}_direction;\n        dAtten = 1.0;\n\n    #else // omni or spot light\n        \n        vec3 lightDirW = evalOmniLight(light{i}_position);\n        dLightDirNormW = normalize(lightDirW);\n\n        // cookie attenuation\n        #if defined(LIGHT{i}COOKIE)\n\n            #if LIGHT{i}TYPE == SPOT\n                #ifdef LIGHT{i}COOKIE_FALLOFF\n                    #ifdef LIGHT{i}COOKIE_TRANSFORM\n                        vec3 cookieAttenuation = getCookie2DXform(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity, light{i}_cookieMatrix, light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};\n                    #else\n                        vec3 cookieAttenuation = getCookie2D(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n                    #endif\n                #else\n                    #ifdef LIGHT{i}COOKIE_TRANSFORM\n                        vec3 cookieAttenuation = getCookie2DClipXform(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity, light{i}_cookieMatrix, light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};\n                    #else\n                        vec3 cookieAttenuation = getCookie2DClip(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n                    #endif\n                #endif\n            #endif\n\n            #if LIGHT{i}TYPE == OMNI\n                vec3 cookieAttenuation = getCookieCube(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n            #endif\n\n            // multiply light color by the cookie attenuation\n            lightColor *= cookieAttenuation;\n\n        #endif\n\n        // distance falloff\n        #if LIGHT{i}SHAPE == PUNCTUAL\n            #if LIGHT{i}FALLOFF == LINEAR\n                dAtten = getFalloffLinear(light{i}_radius, lightDirW);\n            #else\n                dAtten = getFalloffInvSquared(light{i}_radius, lightDirW);\n            #endif\n        #else\n            // non punctual lights only gets the range window here\n            dAtten = getFalloffWindow(light{i}_radius, lightDirW);\n        #endif\n\n        // spot light angle falloff\n        #if LIGHT{i}TYPE == SPOT\n            #if !defined(LIGHT{i}COOKIE) || defined(LIGHT{i}COOKIE_FALLOFF)\n                dAtten *= getSpotEffect(light{i}_direction, light{i}_innerConeAngle, light{i}_outerConeAngle, dLightDirNormW);\n            #endif\n        #endif\n    #endif\n\n    if (dAtten < 0.00001) {\n        return;\n    }\n\n    // evaluate area light values\n    #if LIGHT{i}SHAPE != PUNCTUAL\n        #if LIGHT{i}SHAPE == RECT\n            calcRectLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);\n        #elif LIGHT{i}SHAPE == DISK\n            calcDiskLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);\n        #elif LIGHT{i}SHAPE == SPHERE\n            calcSphereLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);\n        #endif\n    #endif\n\n    // diffuse lighting - LTC lights do not mix diffuse lighting into attenuation that affects specular\n    #if LIGHT{i}SHAPE != PUNCTUAL\n\n        // attenDiffuse - separate diffuse attenuation for non-punctual light sources\n\n        #if LIGHT{i}TYPE == DIRECTIONAL\n            // NB: A better approximation perhaps using wrap lighting could be implemented here\n            float attenDiffuse = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirNormW);\n        #else\n            // 16.0 is a constant that is in getFalloffInvSquared()\n            #if LIGHT{i}SHAPE == RECT\n                float attenDiffuse = getRectLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n            #elif LIGHT{i}SHAPE == DISK\n                float attenDiffuse = getDiskLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n            #elif LIGHT{i}SHAPE == SPHERE\n                float attenDiffuse = getSphereLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n            #endif\n        #endif\n    #else\n        // one parameter is unused for punctual lights\n        dAtten *= getLightDiffuse(litArgs_worldNormal, vec3(0.0), dLightDirNormW);\n    #endif\n\n    // apply the shadow attenuation\n    #ifdef LIGHT{i}CASTSHADOW\n\n        #if LIGHT{i}TYPE == DIRECTIONAL\n            float shadow = getShadow{i}(vec3(0.0));\n        #else\n            float shadow = getShadow{i}(lightDirW);\n        #endif\n\n        // Apply shadow intensity to the shadow value\n        shadow = mix(1.0, shadow, light{i}_shadowIntensity);\n\n        dAtten *= shadow;\n\n        #if defined(LIT_SHADOW_CATCHER) && LIGHT{i}TYPE == DIRECTIONAL\n            // accumulate shadows for directional lights\n            dShadowCatcher *= shadow;\n        #endif            \n\n    #endif\n\n    #if LIGHT{i}SHAPE != PUNCTUAL\n        // area light - they do not mix diffuse lighting into specular attenuation\n        #ifdef LIT_SPECULAR\n            dDiffuseLight += ((attenDiffuse * dAtten) * lightColor) * (1.0 - dLTCSpecFres);\n        #else\n            dDiffuseLight += (attenDiffuse * dAtten) * lightColor;\n        #endif                        \n    #else\n        // punctual light\n        #if defined(AREA_LIGHTS) && defined(LIT_SPECULAR)\n            dDiffuseLight += (dAtten * lightColor) * (1.0 - litArgs_specularity);\n        #else\n            dDiffuseLight += dAtten * lightColor;\n        #endif\n    #endif\n\n    // specular lighting\n    #ifdef LIGHT{i}AFFECT_SPECULARITY\n\n        #if LIGHT{i}SHAPE != PUNCTUAL // area light\n\n            #ifdef LIT_CLEARCOAT\n                #if LIGHT{i}SHAPE == RECT\n                    ccSpecularLight += ccLTCSpecFres * getRectLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;\n                #elif LIGHT{i}SHAPE == DISK\n                    ccSpecularLight += ccLTCSpecFres * getDiskLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;\n                #elif LIGHT{i}SHAPE == SPHERE\n                    ccSpecularLight += ccLTCSpecFres * getSphereLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;\n                #endif\n            #endif\n\n            #ifdef LIT_SPECULAR\n                #if LIGHT{i}SHAPE == RECT\n                    dSpecularLight += dLTCSpecFres * getRectLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;\n                #elif LIGHT{i}SHAPE == DISK\n                    dSpecularLight += dLTCSpecFres * getDiskLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;\n                #elif LIGHT{i}SHAPE == SPHERE\n                    dSpecularLight += dLTCSpecFres * getSphereLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;\n                #endif\n            #endif\n\n        #else // punctual light\n\n            // is fresnel needed\n            #if LIGHT{i}TYPE == DIRECTIONAL && LIT_FRESNEL_MODEL != NONE\n                #define LIGHT{i}FRESNEL\n            #endif\n\n            #ifdef LIT_SPECULAR\n                vec3 halfDirW = normalize(-dLightDirNormW + dViewDirW);\n            #endif\n\n            // if LTC lights are present, specular must be accumulated with specularity (specularity is pre multiplied by punctual light fresnel)\n            #ifdef LIT_CLEARCOAT\n                vec3 lightspecularCC = getLightSpecular(halfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * lightColor;\n                #ifdef LIGHT{i}FRESNEL\n                    lightspecularCC *= getFresnelCC(dot(dViewDirW, halfDirW));\n                #endif\n                ccSpecularLight += lightspecularCC;\n            #endif\n\n            #ifdef LIT_SHEEN\n                sSpecularLight += getLightSpecularSheen(halfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * lightColor;\n            #endif\n\n            #ifdef LIT_SPECULAR\n\n                vec3 lightSpecular = getLightSpecular(halfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * lightColor;\n                #ifdef LIGHT{i}FRESNEL\n\n                    #if defined(LIT_IRIDESCENCE)\n                        lightSpecular *= getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity, iridescenceFresnel, litArgs_iridescence_intensity);\n                    #else\n                        lightSpecular *= getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity);\n                    #endif\n\n                #else\n                    lightSpecular *= litArgs_specularity;\n                #endif\n                \n                dSpecularLight += lightSpecular;\n            #endif\n        #endif\n    #endif\n}\n#endif\n";
export default _default;
