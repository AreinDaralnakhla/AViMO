declare const _default: "\n\nfn _getShadowCoordPerspZbuffer(shadowMatrix: mat4x4f, shadowParams: vec4f, wPos: vec3f) -> vec3f {\n    var projPos = shadowMatrix * vec4f(wPos, 1.0);\n    return projPos.xyz / projPos.w;\n    // depth bias is already applied on render\n}\n\nfn getShadowCoordPerspZbufferNormalOffset(shadowMatrix: mat4x4f, shadowParams: vec4f, normal: vec3f) -> vec3f {\n    let wPos: vec3f = vPositionW + normal * shadowParams.y;\n    return _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\n\nfn normalOffsetPointShadow(shadowParams: vec4f, lightPos: vec3f, lightDir: vec3f, lightDirNorm: vec3f, normal: vec3f) -> vec3f {\n    let distScale: f32 = length(lightDir);\n    let wPos: vec3f = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale; //0.02\n    let dir: vec3f = wPos - lightPos;\n    return dir;\n}\n\n#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n    fn getShadowOmniClusteredPCF1(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowParams: vec4f, omniAtlasViewport: vec3f, shadowEdgePixels: f32, lightDir: vec3f) -> f32 {\n\n        let shadowTextureResolution: f32 = shadowParams.x;\n        let uv: vec2f = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\n        let shadowZ: f32 = length(lightDir) * shadowParams.w + shadowParams.z;\n        return textureSampleCompareLevel(shadowMap, shadowMapSampler, uv, shadowZ);\n    }\n\n#endif\n\n#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n    fn getShadowOmniClusteredPCF3(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowParams: vec4f, omniAtlasViewport: vec3f, shadowEdgePixels: f32, lightDir: vec3f) -> f32 {\n\n        let shadowTextureResolution: f32 = shadowParams.x;\n        let uv: vec2f = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\n        let shadowZ: f32 = length(lightDir) * shadowParams.w + shadowParams.z;\n        let shadowCoord: vec3f = vec3f(uv, shadowZ);\n        return getShadowPCF3x3(shadowMap, shadowMapSampler, shadowCoord, shadowParams);\n    }\n\n#endif\n\n#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n    fn getShadowOmniClusteredPCF5(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowParams: vec4f, omniAtlasViewport: vec3f, shadowEdgePixels: f32, lightDir: vec3f) -> f32 {\n\n        let shadowTextureResolution: f32 = shadowParams.x;\n        let uv: vec2f = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\n        let shadowZ: f32 = length(lightDir) * shadowParams.w + shadowParams.z;\n        let shadowCoord: vec3f = vec3f(uv, shadowZ);\n        return getShadowPCF5x5(shadowMap, shadowMapSampler, shadowCoord, shadowParams);\n    }\n\n#endif\n\n// Clustered Spot Sampling using atlas\n\n#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\n    fn getShadowSpotClusteredPCF1(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {\n        return textureSampleCompareLevel(shadowMap, shadowMapSampler, shadowCoord.xy, shadowCoord.z);\n    }\n\n#endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\n    fn getShadowSpotClusteredPCF3(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {\n        return getShadowSpotPCF3x3(shadowMap, shadowMapSampler, shadowCoord, shadowParams);\n    }\n\n#endif\n\n    #if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\n    fn getShadowSpotClusteredPCF5(shadowMap: texture_depth_2d, shadowMapSampler: sampler_comparison, shadowCoord: vec3f, shadowParams: vec4f) -> f32 {\n        return getShadowPCF5x5(shadowMap, shadowMapSampler, shadowCoord, shadowParams);\n    }\n\n#endif\n";
export default _default;
