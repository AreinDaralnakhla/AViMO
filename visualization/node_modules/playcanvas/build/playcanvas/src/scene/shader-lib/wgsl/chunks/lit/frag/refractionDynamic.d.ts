declare const _default: "\nuniform material_invAttenuationDistance: f32;\nuniform material_attenuation: vec3f;\n\nfn evalRefractionColor(refractionVector: vec3f, gloss: f32, refractionIndex: f32) -> vec3f {\n\n    // The refraction point is the entry point + vector to exit point\n    let pointOfRefraction: vec4f = vec4f(vPositionW + refractionVector, 1.0);\n\n    // Project to texture space so we can sample it\n    let projectionPoint: vec4f = uniform.matrix_viewProjection * pointOfRefraction;\n\n    // use built-in getGrabScreenPos function to convert screen position to grab texture uv coords\n    let uv: vec2f = getGrabScreenPos(projectionPoint);\n\n    // Use IOR and roughness to select mip\n    let iorToRoughness: f32 = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);\n    let refractionLod: f32 = log2(uniform.uScreenSize.x) * iorToRoughness;\n    let refraction: vec3f = textureSampleLevel(uSceneColorMap, uSceneColorMapSampler, uv, refractionLod).rgb;\n\n    return refraction;\n}\n\nfn addRefraction(\n    worldNormal: vec3f,\n    viewDir: vec3f,\n    thickness: f32,\n    gloss: f32,\n    specularity: vec3f,\n    albedo: vec3f,\n    transmission: f32,\n    refractionIndex: f32,\n    dispersion: f32,\n#if defined(LIT_IRIDESCENCE)\n    iridescenceFresnel: vec3f,\n    iridescenceIntensity: f32\n#endif\n) {\n\n    // Extract scale from the model transform\n    var modelScale: vec3f;\n    modelScale.x = length(uniform.matrix_model[0].xyz);\n    modelScale.y = length(uniform.matrix_model[1].xyz);\n    modelScale.z = length(uniform.matrix_model[2].xyz);\n\n    // Calculate the refraction vector, scaled by the thickness and scale of the object\n    let scale: vec3f = thickness * modelScale;\n    var refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * scale;\n    var refraction = evalRefractionColor(refractionVector, gloss, refractionIndex);\n\n    #ifdef LIT_DISPERSION\n        // based on the dispersion material property, calculate modified refraction index values\n        // for R and B channels and evaluate the refraction color for them.\n        let halfSpread: f32 = (1.0 / refractionIndex - 1.0) * 0.025 * dispersion;\n\n        let refractionIndexR: f32 = refractionIndex - halfSpread;\n        refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexR)) * scale;\n        refraction.r = evalRefractionColor(refractionVector, gloss, refractionIndexR).r;\n\n        let refractionIndexB: f32 = refractionIndex + halfSpread;\n        refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexB)) * scale;\n        refraction.b = evalRefractionColor(refractionVector, gloss, refractionIndexB).b;\n    #endif\n\n    // Transmittance is our final refraction color\n    var transmittance: vec3f;\n    if (uniform.material_invAttenuationDistance != 0.0)\n    {\n        let attenuation: vec3f = -log(uniform.material_attenuation) * uniform.material_invAttenuationDistance;\n        transmittance = exp(-attenuation * length(refractionVector));\n    }\n    else\n    {\n        transmittance = refraction;\n    }\n\n    // Apply fresnel effect on refraction\n    let fresnel: vec3f = vec3f(1.0) -\n        getFresnel(\n            dot(viewDir, worldNormal),\n            gloss,\n            specularity\n        #if defined(LIT_IRIDESCENCE)\n            , iridescenceFresnel,\n            iridescenceIntensity\n        #endif\n        );\n    dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);\n}\n";
export default _default;
