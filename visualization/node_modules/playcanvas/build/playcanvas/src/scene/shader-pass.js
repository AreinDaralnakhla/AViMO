import { DeviceCache } from '../platform/graphics/device-cache.js';
import { SHADER_FORWARD, SHADER_PICK } from './constants.js';

const shaderPassDeviceCache = new DeviceCache();
class ShaderPassInfo {
		constructor(name, index, options = {}){
				this.defines = new Map();
				this.name = name;
				this.index = index;
				Object.assign(this, options);
				this.buildShaderDefines();
		}
		buildShaderDefines() {
				let keyword;
				if (this.isShadow) {
						keyword = 'SHADOW';
				} else if (this.isForward) {
						keyword = 'FORWARD';
				} else if (this.index === SHADER_PICK) {
						keyword = 'PICK';
				}
				this.defines.set(`${keyword}_PASS`, '');
				this.defines.set(`${this.name.toUpperCase()}_PASS`, '');
		}
}
class ShaderPass {
		constructor(){
				this.passesNamed = new Map();
				this.passesIndexed = [];
				this.nextIndex = 0;
				const add = (name, index, options)=>{
						this.allocate(name, options);
				};
				add('forward', SHADER_FORWARD, {
						isForward: true
				});
				add('prepass');
				add('shadow');
				add('pick');
		}
		static get(device) {
				return shaderPassDeviceCache.get(device, ()=>{
						return new ShaderPass();
				});
		}
		allocate(name, options) {
				let info = this.passesNamed.get(name);
				if (info === undefined) {
						info = new ShaderPassInfo(name, this.nextIndex, options);
						this.passesNamed.set(info.name, info);
						this.passesIndexed[info.index] = info;
						this.nextIndex++;
				}
				return info;
		}
		getByIndex(index) {
				const info = this.passesIndexed[index];
				return info;
		}
		getByName(name) {
				return this.passesNamed.get(name);
		}
}

export { ShaderPass, ShaderPassInfo };
