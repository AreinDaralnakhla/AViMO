import { EventHandler } from '../../core/event-handler.js';
import { platform } from '../../core/platform.js';
import { XrAnchor } from './xr-anchor.js';

class XrAnchors extends EventHandler {
		static{
				this.EVENT_AVAILABLE = 'available';
		}
		static{
				this.EVENT_UNAVAILABLE = 'unavailable';
		}
		static{
				this.EVENT_ERROR = 'error';
		}
		static{
				this.EVENT_ADD = 'add';
		}
		static{
				this.EVENT_DESTROY = 'destroy';
		}
		constructor(manager){
				super(), this._supported = platform.browser && !!window.XRAnchor, this._available = false, this._checkingAvailability = false, this._persistence = platform.browser && !!window?.XRSession?.prototype.restorePersistentAnchor, this._creationQueue = [], this._index = new Map(), this._indexByUuid = new Map(), this._list = [], this._callbacksAnchors = new Map();
				this.manager = manager;
				if (this._supported) {
						this.manager.on('start', this._onSessionStart, this);
						this.manager.on('end', this._onSessionEnd, this);
				}
		}
		_onSessionStart() {
				const available = this.manager.session.enabledFeatures?.indexOf('anchors') >= 0;
				if (!available) return;
				this._available = available;
				this.fire('available');
		}
		_onSessionEnd() {
				if (!this._available) return;
				this._available = false;
				for(let i = 0; i < this._creationQueue.length; i++){
						if (!this._creationQueue[i].callback) {
								continue;
						}
						this._creationQueue[i].callback(new Error('session ended'), null);
				}
				this._creationQueue.length = 0;
				this._index.clear();
				this._indexByUuid.clear();
				let i = this._list.length;
				while(i--){
						this._list[i].destroy();
				}
				this._list.length = 0;
				this.fire('unavailable');
		}
		_createAnchor(xrAnchor, uuid = null) {
				const anchor = new XrAnchor(this, xrAnchor, uuid);
				this._index.set(xrAnchor, anchor);
				if (uuid) this._indexByUuid.set(uuid, anchor);
				this._list.push(anchor);
				anchor.once('destroy', this._onAnchorDestroy, this);
				return anchor;
		}
		_onAnchorDestroy(xrAnchor, anchor) {
				this._index.delete(xrAnchor);
				if (anchor.uuid) this._indexByUuid.delete(anchor.uuid);
				const ind = this._list.indexOf(anchor);
				if (ind !== -1) this._list.splice(ind, 1);
				this.fire('destroy', anchor);
		}
		create(position, rotation, callback) {
				if (!this._available) {
						callback?.(new Error('Anchors API is not available'), null);
						return;
				}
				if (window.XRHitTestResult && position instanceof XRHitTestResult) {
						const hitResult = position;
						callback = rotation;
						if (!this._supported) {
								callback?.(new Error('Anchors API is not supported'), null);
								return;
						}
						if (!hitResult.createAnchor) {
								callback?.(new Error('Creating Anchor from Hit Test is not supported'), null);
								return;
						}
						hitResult.createAnchor().then((xrAnchor)=>{
								const anchor = this._createAnchor(xrAnchor);
								callback?.(null, anchor);
								this.fire('add', anchor);
						}).catch((ex)=>{
								callback?.(ex, null);
								this.fire('error', ex);
						});
				} else {
						this._creationQueue.push({
								transform: new XRRigidTransform(position, rotation),
								callback: callback
						});
				}
		}
		restore(uuid, callback) {
				if (!this._available) {
						callback?.(new Error('Anchors API is not available'), null);
						return;
				}
				if (!this._persistence) {
						callback?.(new Error('Anchor Persistence is not supported'), null);
						return;
				}
				if (!this.manager.active) {
						callback?.(new Error('WebXR session is not active'), null);
						return;
				}
				this.manager.session.restorePersistentAnchor(uuid).then((xrAnchor)=>{
						const anchor = this._createAnchor(xrAnchor, uuid);
						callback?.(null, anchor);
						this.fire('add', anchor);
				}).catch((ex)=>{
						callback?.(ex, null);
						this.fire('error', ex);
				});
		}
		forget(uuid, callback) {
				if (!this._available) {
						callback?.(new Error('Anchors API is not available'));
						return;
				}
				if (!this._persistence) {
						callback?.(new Error('Anchor Persistence is not supported'));
						return;
				}
				if (!this.manager.active) {
						callback?.(new Error('WebXR session is not active'));
						return;
				}
				this.manager.session.deletePersistentAnchor(uuid).then(()=>{
						callback?.(null);
				}).catch((ex)=>{
						callback?.(ex);
						this.fire('error', ex);
				});
		}
		update(frame) {
				if (!this._available) {
						if (!this.manager.session.enabledFeatures && !this._checkingAvailability) {
								this._checkingAvailability = true;
								frame.createAnchor(new XRRigidTransform(), this.manager._referenceSpace).then((xrAnchor)=>{
										xrAnchor.delete();
										if (this.manager.active) {
												this._available = true;
												this.fire('available');
										}
								}).catch(()=>{});
						}
						return;
				}
				if (this._creationQueue.length) {
						for(let i = 0; i < this._creationQueue.length; i++){
								const request = this._creationQueue[i];
								frame.createAnchor(request.transform, this.manager._referenceSpace).then((xrAnchor)=>{
										if (request.callback) {
												this._callbacksAnchors.set(xrAnchor, request.callback);
										}
								}).catch((ex)=>{
										if (request.callback) {
												request.callback(ex, null);
										}
										this.fire('error', ex);
								});
						}
						this._creationQueue.length = 0;
				}
				for (const [xrAnchor, anchor] of this._index){
						if (frame.trackedAnchors.has(xrAnchor)) {
								continue;
						}
						this._index.delete(xrAnchor);
						anchor.destroy();
				}
				for(let i = 0; i < this._list.length; i++){
						this._list[i].update(frame);
				}
				for (const xrAnchor of frame.trackedAnchors){
						if (this._index.has(xrAnchor)) {
								continue;
						}
						try {
								const tmp = xrAnchor.anchorSpace;
						} catch (ex) {
								continue;
						}
						const anchor = this._createAnchor(xrAnchor);
						anchor.update(frame);
						const callback = this._callbacksAnchors.get(xrAnchor);
						if (callback) {
								this._callbacksAnchors.delete(xrAnchor);
								callback(null, anchor);
						}
						this.fire('add', anchor);
				}
		}
		get supported() {
				return this._supported;
		}
		get available() {
				return this._available;
		}
		get persistence() {
				return this._persistence;
		}
		get uuids() {
				if (!this._available) {
						return null;
				}
				if (!this._persistence) {
						return null;
				}
				if (!this.manager.active) {
						return null;
				}
				return this.manager.session.persistentAnchors;
		}
		get list() {
				return this._list;
		}
}

export { XrAnchors };
