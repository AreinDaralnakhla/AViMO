import { TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT, PIXELFORMAT_RGBA8, SHADERSTAGE_COMPUTE } from './constants.js';

let id = 0;
class BindBaseFormat {
		constructor(name, visibility){
				this.slot = -1;
				this.scopeId = null;
				this.name = name;
				this.visibility = visibility;
		}
}
class BindUniformBufferFormat extends BindBaseFormat {
}
class BindStorageBufferFormat extends BindBaseFormat {
		constructor(name, visibility, readOnly = false){
				super(name, visibility), this.format = '';
				this.readOnly = readOnly;
		}
}
class BindTextureFormat extends BindBaseFormat {
		constructor(name, visibility, textureDimension = TEXTUREDIMENSION_2D, sampleType = SAMPLETYPE_FLOAT, hasSampler = true, samplerName = null){
				super(name, visibility);
				this.textureDimension = textureDimension;
				this.sampleType = sampleType;
				this.hasSampler = hasSampler;
				this.samplerName = samplerName ?? `${name}_sampler`;
		}
}
class BindStorageTextureFormat extends BindBaseFormat {
		constructor(name, format = PIXELFORMAT_RGBA8, textureDimension = TEXTUREDIMENSION_2D, write = true, read = false){
				super(name, SHADERSTAGE_COMPUTE);
				this.format = format;
				this.textureDimension = textureDimension;
				this.write = write;
				this.read = read;
		}
}
class BindGroupFormat {
		constructor(graphicsDevice, formats){
				this.uniformBufferFormats = [];
				this.textureFormats = [];
				this.storageTextureFormats = [];
				this.storageBufferFormats = [];
				this.id = id++;
				let slot = 0;
				formats.forEach((format)=>{
						format.slot = slot++;
						if (format instanceof BindTextureFormat && format.hasSampler) {
								slot++;
						}
						if (format instanceof BindUniformBufferFormat) {
								this.uniformBufferFormats.push(format);
						} else if (format instanceof BindTextureFormat) {
								this.textureFormats.push(format);
						} else if (format instanceof BindStorageTextureFormat) {
								this.storageTextureFormats.push(format);
						} else if (format instanceof BindStorageBufferFormat) {
								this.storageBufferFormats.push(format);
						} else ;
				});
				this.device = graphicsDevice;
				const scope = graphicsDevice.scope;
				this.bufferFormatsMap = new Map();
				this.uniformBufferFormats.forEach((bf, i)=>this.bufferFormatsMap.set(bf.name, i));
				this.textureFormatsMap = new Map();
				this.textureFormats.forEach((tf, i)=>{
						this.textureFormatsMap.set(tf.name, i);
						tf.scopeId = scope.resolve(tf.name);
				});
				this.storageTextureFormatsMap = new Map();
				this.storageTextureFormats.forEach((tf, i)=>{
						this.storageTextureFormatsMap.set(tf.name, i);
						tf.scopeId = scope.resolve(tf.name);
				});
				this.storageBufferFormatsMap = new Map();
				this.storageBufferFormats.forEach((bf, i)=>{
						this.storageBufferFormatsMap.set(bf.name, i);
						bf.scopeId = scope.resolve(bf.name);
				});
				this.impl = graphicsDevice.createBindGroupFormatImpl(this);
		}
		destroy() {
				this.impl.destroy();
		}
		getTexture(name) {
				const index = this.textureFormatsMap.get(name);
				if (index !== undefined) {
						return this.textureFormats[index];
				}
				return null;
		}
		getStorageTexture(name) {
				const index = this.storageTextureFormatsMap.get(name);
				if (index !== undefined) {
						return this.storageTextureFormats[index];
				}
				return null;
		}
		loseContext() {}
}

export { BindGroupFormat, BindStorageBufferFormat, BindStorageTextureFormat, BindTextureFormat, BindUniformBufferFormat };
