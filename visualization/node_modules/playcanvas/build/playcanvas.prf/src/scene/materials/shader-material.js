import { SHADERLANGUAGE_GLSL, SHADERLANGUAGE_WGSL } from '../../platform/graphics/constants.js';
import { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';
import { SHADERDEF_MORPH_TEXTURE_BASED_INT, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_POSITION, SHADERDEF_INSTANCING, SHADERDEF_SKIN } from '../constants.js';
import { getProgramLibrary } from '../shader-lib/get-program-library.js';
import { shaderGeneratorShader } from '../shader-lib/programs/shader-generator-shader.js';
import { ShaderUtils } from '../shader-lib/shader-utils.js';
import { Material } from './material.js';

class ShaderMaterial extends Material {
		constructor(shaderDesc){
				super();
				this.shaderDesc = shaderDesc;
		}
		set shaderDesc(value) {
				this._shaderDesc = undefined;
				if (value) {
						this._shaderDesc = {
								uniqueName: value.uniqueName,
								attributes: value.attributes,
								fragmentOutputTypes: value.fragmentOutputTypes,
								vertexGLSL: value.vertexGLSL,
								fragmentGLSL: value.fragmentGLSL,
								vertexWGSL: value.vertexWGSL,
								fragmentWGSL: value.fragmentWGSL
						};
						if (value.vertexCode || value.fragmentCode || value.shaderLanguage) {
								const language = value.shaderLanguage ?? SHADERLANGUAGE_GLSL;
								if (language === SHADERLANGUAGE_GLSL) {
										this._shaderDesc.vertexGLSL = value.vertexCode;
										this._shaderDesc.fragmentGLSL = value.fragmentCode;
								} else if (language === SHADERLANGUAGE_WGSL) {
										this._shaderDesc.vertexWGSL = value.vertexCode;
										this._shaderDesc.fragmentWGSL = value.fragmentCode;
								}
						}
				}
				this.clearVariants();
		}
		get shaderDesc() {
				return this._shaderDesc;
		}
		copy(source) {
				super.copy(source);
				this.shaderDesc = source.shaderDesc;
				return this;
		}
		getShaderVariant(params) {
				const { objDefs } = params;
				const options = {
						defines: ShaderUtils.getCoreDefines(this, params),
						skin: (objDefs & SHADERDEF_SKIN) !== 0,
						useInstancing: (objDefs & SHADERDEF_INSTANCING) !== 0,
						useMorphPosition: (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
						useMorphNormal: (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
						useMorphTextureBasedInt: (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0,
						pass: params.pass,
						gamma: params.cameraShaderParams.shaderOutputGamma,
						toneMapping: params.cameraShaderParams.toneMapping,
						fog: params.cameraShaderParams.fog,
						shaderDesc: this.shaderDesc,
						shaderChunks: this.shaderChunks
				};
				const processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
				const library = getProgramLibrary(params.device);
				library.register('shader-material', shaderGeneratorShader);
				return library.getProgram('shader-material', options, processingOptions, this.userId);
		}
}

export { ShaderMaterial };
